\input texinfo   @c -*-texinfo-*-
@setfilename qdpc.info
@settitle QDP/C User Manual

@include qdpdefs.texi

@c start titlepage, only used in TeX mode
@titlepage
@title QDP/C User Manual
Version 1.8.0

This document provides a detailed description of the C implementation of the@*
SciDAC Level 2 QDP Data Parallel interface.

@author C. DeTar and J.C. Osborn
with the SciDAC Software Committee
@end titlepage

@c Title for non-TeX output
@ifnottex
@node Top, Introduction, (dir), (dir)
@c @top QDP/C User Manual
Version 1.8.0

This document provides a detailed description of the C implementation of the@*
SciDAC Level 2 QDP Data Parallel interface.
@end ifnottex

@contents

@menu
* Introduction::                Introduction to QDP/C.
* Compilation with QDP::        How to compile a program that uses QDP.
* Datatypes::                   Datatypes.
* QDP Functions::               QDP Functions.
* Function Details::            Function Details.
@end menu


@c ====================================================================
@node     Introduction, Compilation with QDP, Top, Top
@chapter  Introduction
@c ====================================================================

This is the detailed user's guide for the C binding of the QDP Data Parallel
Applications Programmer Interface developed under the auspices of the
U.S. Department of Energy Scientific Discovery through Advanced
Computing (SciDAC) program.

The QDP Level 2 API has the following features:

@itemize @bullet
@item
Can specify a physical lattice of any size and number of dimensions.
@item
Automatically handles the layout of the lattice across the machine.
@item
Provides functions for creating and destroying fields on the lattice
along with a large set of data parallel operations (logically SIMD)
acting on all sites across the lattice or on subsets of these sites.
@item
Allows creation of arbitrary subsets of sites.
@item
All math operations are handled by the SciDAC QLA library which has
optimized versions for SSE (Intel, AMD) and 440 (QCDOC, BG/L) architectures.
@item
Allows asynchronous (non-blocking) shifts of lattice level
objects over any permutation map of sites onto sites.
@item
Automatically handles dependency of shifts and waits on the results only
when needed.
@item
Uses the SciDAC QMP library for communications which is available for
all MPI platforms and QCDOC.
@item
Provides some combined shift and linear algebra instructions for
convenience and optimization.
@item
Provides fill operations (filling a lattice quantity from a
scalar value(s)), global reduction operations, and lattice-wide
operations on various data-type primitives, such as matrices, vectors
and propagators.
@item
Has flexible I/O capabilities allowing reading and writing of all lattice
fields and also global data.
@item
Uses SciDAC QIO library for I/O which is compatible with the USQCD and ILDG
standards.
@end itemize


@c ====================================================================
@node     Compilation with QDP, Datatypes, Introduction, Top
@chapter  Compilation with QDP
@c ====================================================================

@menu
* Header and macros::           
* Libraries::                   
* Nonuniform color and precision::  
@end menu

@node Header and macros, Libraries, Compilation with QDP, Compilation with QDP
@section Header and macros

The main header file for QDP is @code{qdp.h} and must be included in all
QDP programs.  This will automatically include any other header files
that are necessary for the specified number of colors and will also include
the QLA headers. Typically the user will want to select a prevailing color and
precision for the entire calculation.  This allows one 
to use generic function names and datatypes, making it possible to
change colors and precision with a simple recompilation, if desired.
The following macros can be defined by the user prior to including this
header file:

@multitable @columnfractions .2 .23 .15
@hline
@item Optional Macros    @tab Choices           @tab Default
@hline
@item @qdpPrecisionMacro @tab 'F', 1, 'D', 2    @tab 'F'
@item @qdpNcMacro        @tab number of colors  @tab 3
@item @qdpColorsMacro    @tab 2, 3, 'N'         @tab 3
@hline
@end multitable

@noindent
Single quotes are required around nonnumeric values.  
The @qdpPrecisionMacro{} macro sets the default precision to either
single (1 or 'F') or double (2 or 'D').
The @qdpNcMacro{} macro sets the default number of colors and can be
any positive integer.  Note however that QLA may have been compiled with
a limit on the maximum allowed value.
@qdpColorsMacro{} determines which QDP and QLA library versions will
be used for calculations.  It is automatically set to
 @emph{2} when @qdpNcMacro{} is @emph{2},
@emph{3} when @emph{3}, and @emph{N} otherwise.
If for some reason a users wishes to work with the @emph{N} namespace
for two or three colors, rather than the more efficient @emph{2} or @emph{3}
namespace, they may do so by setting this macro to @emph{'N'} explicitly.

The number of spins is fixed in QDP to be the same value that the QLA
library that QDP was compiled against has which defaults to 4.

A sample preamble for double precision SU(3) reads

@example
#define QDP_Precision 'D'
#define QDP_Nc 3
#include <qdp.h>
@end example

@noindent
with the include search path set to @file{QDP_HOME/include}
and @file{QDP_HOME} set to the home directory for QDP.
With such a preamble the generic function names and datatypes are
automatically mapped to the appropriate specific types.
Of course the precision and color macros can also be defined
through a compiler flag, as in

@command{gcc -DQDP_Precision=2 -DQDP_Nc=3 ...}

@noindent
For SU(4) one might do

@example
#define QDP_Precision 'F'
#define QDP_Nc 4
#include <qdp.h>
@end example

@node Libraries, Nonuniform color and precision, Header and macros, Compilation with QDP
@section Libraries

Normally, it is necessary to link four QDP libraries for a given
choice of color and precision.  Other libraries may be required if mixing
precisions or numbers of color.
Routines involving only integers and the random state
are common to all choices.  Routines involving only real or complex
numbers are common to all colors.  Thus for single precision SU(3)
the required libraries are linked through

@command{-lqdp_f3 -lqdp_f -lqdp_int -lqdp_common}

@noindent
with the library search path set to @file{QDP_HOME/lib}.
Each library will depend on the corresponding QLA library.
Also since global sums are done in a higher precision, using them
requires linking to QLA libraries of the next higher precision in
addition to the corresponding conversion library.
For the above example one would also need

@command{-lqla_f3 -lqla_f -lqla_d3 -lqla_d -lqla_df3 -lqla_df -lqla_int -lqla_random -lqla_cmath -lm}

@noindent
in addition to the QIO and QMP libraries which typically are

@command{-lqio -llime -lqmp}

@noindent
and any other system dependent libraries such as MPI.
A complete list of the QDP libraries is given below.

@multitable @columnfractions .25 .45
@hline
@item Name                      @tab Purpose
@hline
@item @file{libqdp_common.a}    @tab QDP utilities
@item @file{libqdp_int.a}       @tab integer and boolean
@item @file{libqdp_f.a}         @tab real and complex single precision
@item @file{libqdp_d.a}         @tab real and complex double precision
@item @file{libqdp_df.a}        @tab real and complex precision conversion
@item @file{libqdp_f2.a}        @tab 2 color single precision
@item @file{libqdp_d2.a}        @tab 2 color double precision
@item @file{libqdp_df2.a}       @tab 2 color precision conversion
@item @file{libqdp_f3.a}        @tab 3 color single precision
@item @file{libqdp_d3.a}        @tab 3 color double precision
@item @file{libqdp_df3.a}       @tab 3 color precision conversion
@item @file{libqdp_fn.a}        @tab N color single precision
@item @file{libqdp_dn.a}        @tab N color double precision
@item @file{libqdp_dfn.a}       @tab N color precision conversion
@hline
@end multitable

@node Nonuniform color and precision,  , Libraries, Compilation with QDP
@section Nonuniform color and precision

Users wishing to vary color and precision within a single calculation
must use specific type names and function names whenever these types
and names differ from the prevailing precision and color.
If using different colors that the specified value then one must also include
the necessary headers.
For example, if a single precision SU(3) calculation also uses some
SU(2) datatypes or operations, the following preamble is appropriate:

@example
#define QDP_Precision 'F'
#define QDP_Nc 3
#include <qdp.h>
#include <qdp_f2.h>
@end example

@noindent
and the following linkage to get the corresponding libraries:

@noindent
@command{-lqdp_f2 -lqdp_f3 -lqdp_f -lqdp_int -lqdp_common}

Note that the single, double and conversion headers for the prevailing
color are automatically included through @file{qdp.h}.
Only when mixing colors does one need to specify individual headers.

The following table lists all the QDP headers.

@multitable @columnfractions .3 .7
@hline
@item Name              @tab Purpose
@hline
@item @file{qdp.h}      @tab Master header and QDP utilities
@item @file{qdp_int.h}  @tab integers, boolean
@item @file{qdp_f.h}    @tab real, complex, single precision
@item @file{qdp_d.h}    @tab real, complex, double precision
@item @file{qdp_df.h}   @tab real, complex, precision conversion
@item @file{qdp_f2.h}   @tab SU(2), single precision
@item @file{qdp_d2.h}   @tab SU(2), double precision
@item @file{qdp_df2.h}  @tab SU(2), precision conversion
@item @file{qdp_f3.h}   @tab SU(3), single precision
@item @file{qdp_d3.h}   @tab SU(3), double precision
@item @file{qdp_df3.h}  @tab SU(3), precision conversion
@item @file{qdp_fn.h}   @tab SU(N), single precision
@item @file{qdp_dn.h}   @tab SU(N), double precision
@item @file{qdp_dfn.h}  @tab SU(N), precision conversion
@hline
@end multitable


@c ====================================================================
@node     Datatypes, QDP Functions, Compilation with QDP, Top
@chapter  Datatypes
@c ====================================================================

The @math{N_d} dimensional lattice consists of all the space-time sites in
the problem space.  Lattice data are fields on these sites.  A data
primitive describes data on a single site.  The lattice fields consist
of the primitives over all sites.  We do not define data types
restricted to a subset of the lattice -- rather, lattice fields occupy
the entire lattice.

@menu
* Generic Names::               
* Specific Types for Color and Precision::  
* Color and Precision Uniformity::  
* Breaking Color and Precision Uniformity::  
@end menu

@node    Generic Names, Specific Types for Color and Precision, Datatypes, Datatypes
@section Generic Names

The linear algebra portion of the QDP API is designed to resemble the
Level 1 QLA API.  Thus the datatypes and function naming conventions
are similar.  As with QLA there are two levels of generic naming:
fully generic in which both color and precision may be controlled
globally through two macros and color-generic in which precision is
explicit but not color.  Generic naming applies to datatypes, module
names, and accessor macros and follows similar rules.

Names for fully generic datatypes are listed in the table below.

@multitable @columnfractions .3 .2 .5
@hline
@item Name @tab Abbreviation @tab Description
@hline
@item @ctS @tab @aS          @tab implementation dependent
@item @ctI @tab @aI          @tab integer
@item @ctR @tab @aR          @tab real
@item @ctC @tab @aC          @tab complex
@item @ctV @tab @aV          @tab one-spin, @math{N_c} color spinor
@item @ctH @tab @aH          @tab two-spin, @math{N_c} color spinor
@item @ctD @tab @aD          @tab four-spin, @math{N_c} color spinor
@item @ctM @tab @aM          @tab @math{N_c \times N_c} complex matrix
@item @ctP @tab @aP          @tab @math{4 N_c \times 4 N_c} complex matrix
@hline
@end multitable

@noindent
The name for the corresponding primitive type, also known as the QLA
type, is obtained by replacing the @code{QDP} prefix with a @code{QLA}
prefix.  Thus @ctqlaM{} is the primitive (QLA) type associated
with the field @ctM{}.

Names for color-generic datatypes are obtained by inserting
@code{_F} for single precision or @code{_D} for double precision
after @code{QDP} where appropriate.
Thus @code{QDP_D_ColorMatrix} specifies a double precision color
matrix with color to be set through a global macro.

A long double precision type with abbreviation @code{Q} is defined for
QLA, but currently not for QDP.

@node    Specific Types for Color and Precision, Color and Precision Uniformity, Generic Names, Datatypes
@section Specific Types for Color and Precision

According to the chosen color and precision, names for specific
floating point types are constructed from names for generic types.
Thus @tM becomes @code{QDP_PC_ColorMatrix}, where the precision
@code{P} is @code{F} or @code{D} according to the table below

@float
@multitable @columnfractions .3 .7
@hline
@item Abbreviation @tab Description
@hline
@item @code{F}     @tab single precision
@item @code{D}     @tab double precision
@hline
@end multitable
@end float

@noindent
and @code{C} is @code{2}, @code{3}, or @code{N}, if color is a
consideration, as listed below.

@multitable @columnfractions .3 .7
@hline
@item Abbreviation @tab Description
@hline
@item @code{2}     @tab SU(2)
@item @code{3}     @tab SU(3)
@item @code{N}     @tab SU(N)
@hline
@end multitable

@noindent
If the datatype carries no color, the color label is omitted.
Integers also have no precision label.  Likewise for functions, if
none of the arguments carry color, the color label is omitted, and if
all numeric arguments are integers, the precision label is omitted.
For example, the type @code{QDP_F3_DiracFermion}
describes a single-precision four-spin, three-color spinor field.
The general color choice @code{N} can also be used for specialized
SU(2) or SU(3) at the cost of degrading performance.

@node    Color and Precision Uniformity, Breaking Color and Precision Uniformity, Specific Types for Color and Precision, Datatypes
@section Color and Precision Uniformity

In standard coding practice it is assumed that a user keeps one of the
precision and color options in force throughout the compilation.  So
as a rule all functions in the interface take operands of the same
precision and color.  As with data type names, function names come in
generic and color- and precision-specific forms, as described in the
next section.  Exceptions to this rule are functions that explicitly
convert from double to single precision and vice versa.  These and
functions that do not depend on color or precision are divided among
thirteen separate libraries.  If the user chooses to adopt color and
precision uniformity, then all variables can be defined with generic
types and all functions accessed through generic names.  The
prevailing color and precision is then defined through macros.  The
interface automatically translates data type names and function names
to the appropriate specific type names through typedefs and macros.
With such a scheme and careful coding, changing only two macros and
the QDP library converts code from one color and precision choice to
another.

@node Breaking Color and Precision Uniformity,  , Color and Precision Uniformity, Datatypes
@section Breaking Color and Precision Uniformity

It is permissible for a user to mix precision and color choices.  This
is done by declaring variables with specific type names, using
functions with specific names, and making appropriate precision
conversions when needed.  In this case it may be necessary to link
against a larger set of libraries.


@c ====================================================================
@node     QDP Functions, Function Details, Datatypes, Top
@chapter  QDP Functions
@c ====================================================================

The QDP functions are grouped into the following categories:

@itemize
@item Entry and exit from QDP
@item Layout utilities
@item Data parallel functions
@item Data management utilities
@item Subset definition
@item Shift creation
@item I/O utilities
@item Temporary exit and reentry
@item Optimization calls
@end itemize

@menu
* Entry and exit from QDP::     
* Layout utilities::            
* Naming Conventions for Data Parallel Functions::  
* Creating and destroying lattice fields::  
* Subsets::                     
* Shifts::                      
* I/O utilities::               
* Temporary entry and exit from QDP::  
* Optimization Calls::          
@end menu

@node Entry and exit from QDP, Layout utilities, QDP Functions, QDP Functions
@section Entry and exit from QDP

QDP must first be initialized before any QDP functions are to be used
except for @code{QDP_is_initialized()} which may be called anytime.
Initializing QDP also initializes QMP if it has not already been done.
Thus the user can safely start QMP before QDP and do any necessary
broadcasts or other operations.
Before any QDP field operations are done one must also create the
 lattice layout.

@c @subheading Entry to QDP
@sfunce{
Entry to QDP,
void QDP_initialize,
int *argc@comma{} char ***argv,
Starts QDP.,
QDP_initialize(&argc@comma{} &argv);}

The routine @code{QDP_initialize} is called once by all nodes and
starts QDP operations.
It initialiazes message passing (if not already done),
 but does not setup the site layout
(see @code{QDP_create_layout} and related functions).
It also defines the global variable
@code{int QDP_this_node;}
specifying the logical node number of the current node.

@c @subheading Exit from QDP
@sfunce{
Exit from QDP,
void QDP_finalize,
void,
Exits QDP.,
QDP_finalize();}

This call provides for an orderly shutdown.  It is called by all
nodes. It also finalizes QMP only if it was initialized by QDP.
If profiling was turned on in any functions then node 0 will dump some
statistics to @code{stdout}.
Then it returns control to the calling process.

@c @subheading Panic exit from QDP
@sfunce{
Panic exit from QDP,
void QDP_abort,
int status,
Panic shutdown of the process.,
QDP_abort(1);}

This routine may be called by one or more nodes.  It sends kill
signals to all nodes and exits with exit status @code{status}.

@c @subheading Check for initialization
@sfunce{
Check for initialization,
int QDP_is_initialized,
void,
Checks if QDP is initialized.,
if(!QDP_is_initialized()) QDP_initialize(&argc@comma{} &argv);}

@c @subheading Control profiling
@sfunce{
Control profiling,
int QDP_profcontrol,
int new,
Controls profiling.,
old = QDP_profcontrol(new);}

Profiling results are only available for code that is compiled with
the macro @code{QDP_PROFILE} defined.  This must be defined before
the qdp.h header is included.  When @code{QDP_finalize} is called
a list of QDP function and call times will be sent to stdout on
node 0.  This function toggles the accumulation of the profiling
statistics within the profiled sections of code.
A value of zero turns the collection of timing info off and
nonzero values turn it on.  It is on by default.

@c @subheading Control checking communications
@sfunce{
Control checking communications,
int QDP_check_comm,
int new,
Controls checking communications.,
old = QDP_check_comm(new);}

A nonzero value turns the internal communications checksums on and
zero turns it off.  It is off by default.


@node Layout utilities, Naming Conventions for Data Parallel Functions, Entry and exit from QDP, QDP Functions
@section Layout utilities

The layout routine determines which nodes get which lattice sites and
in what linear order the sites are stored.  It has entry points that
allow a user to access single site data extracted from a QDP lattice
field.  The layout must be created before any operations on QDP field
objects are allowed.  If a user removes data from a QDP lattice object
(see @code{QDP_expose} or @code{QDP_extract}) and wishes to manipulate
the data on a site-by-site basis, the global entry points provided
here are needed to locate the site data.

The current QDP/C implementation allows only hypercubic layouts with
the same sublattice dimensions on every node.
It would be relatively easy to add other layouts if the need arised.
@c Some implementations may have a built-in tightly constrained layout.
@c In flexible implementations there may be several layout choices,
@c thereby allowing the user the freedom to select one that works best
@c with a given application.  Furthermore, such implementations may allow
@c the user to create a custom layout to replace one of the standard
@c layouts.  As long as the custom layout procedure provides the entry
@c points and functionality described here, compatibility with the
@c remainder of the QDP library is assured.

@subheading Defining the layout

Prior to creating the layout the layout parameters must be defined.
This is done through function calls.

@funce{
void QDP_set_latsize,
int nd@comma{} int size[],
Sets number of spacetime dimensions and lattice size.@*
No default.  Must always be set.,
QDP_set_latsize(4@comma{} size);}

@funce{
void QDP_create_layout,
void,
Lays out the sites.,
QDP_create_layout();}

All layout parameters must be initialized through the @code{set} function
calls prior to creating the layout.

After creating the layout the following global variables are accessible.
The predefined lattice subsets for specifying even, odd, and
global subsets of the lattice:

@code{QDP_Subset QDP_even, QDP_odd, QDP_all;}

The even and odd subsets are elements of a two-element subset array
@code{QDP_even_odd}, such that

@example
@code{QDP_even = QDP_even_odd[0];}
@code{QDP_odd  = QDP_even_odd[1];}
@end example

It also creates the nearest-neighbor shifts 

@code{QDP_shift QDP_neighbor[];}

for each coordinate direction.  
And finally the variable

@code{int QDP_sites_on_node;}

gives the number of sites assigned to a node by the layout utility.
Note that this may vary between nodes.

The following global entry points are provided by the
@code{QDP_create_layout} procedure:

@c @subheading Number of dimensions
@sfunce{
Number of dimensions,
int QDP_ndim,
void,
Returns the number of dimensions.,
ndim = QDP_ndim();}

@c @subheading Length of lattice in a given direction
@sfunce{
Length of lattice in a given direction,
int QDP_coord_size,
int i,
Returns length of lattice in direction @code{i}.,
nx = QDP_coord_size(0);}

@c @subheading Length of lattice in all directions
@sfunce{
Length of lattice in all directions,
void QDP_latsize,
int latsize[],
Returns lattice dimensions into array @code{latsize}.,
QDP_latsize(latsize);}

@c @subheading Length of lattice in all directions
@sfunce{
Length of lattice in all directions,
size_t QDP_volume,
void,
Returns lattice volume.,
vol = QDP_volume();}

@c @subheading Node number of site
@sfunce{
Node number of site,
int QDP_node_number,
int x[],
Returns logical node number containing site @code{x}.,
node = QDP_node_number(x);}

@c @subheading Linear index of site
@sfunce{
Linear index of site,
int QDP_index,
int x[],
Returns the linearized index for the lattice site @code{x}.,
k = QDP_index(x);}

The linear index returned by @code{QDP_index} ranges from 0 to
@code{QDP_sites_on_node} - 1.

@c @subheading Number of sites on a node
@sfunce{
Number of sites on a node,
int QDP_numsites,
int node,
Return the number of sites on a node.  Same as @code{QDP_sites_on_node}
if @code{node = QDP_this_node},
k = QDP_numsites(i);}

@c @subheading Map node and linear index to coordinate
@sfunce{
Map node and linear index to coordinate,
void QDP_get_coords,
int x[]@comma{} int node@comma{} int index,
Returns site coordinates @code{x} for the given node
@code{node} and linear index @code{index}.,
QDP_get_coords(x@comma{} 0@comma{} 31);}

@c @subheading Defining the spacetime coordinate
@sfunce{
Defining the spacetime coordinate,
void QDP_I_eq_coord,
@tI{} *r@comma{} int i,
The @code{i}th spacetime coordinate.,
QDP_Int *coord_z;@*
QDP_I_eq_coord(coord_z@comma{} 2);}

The call @code{QDP_I_eq_coord(&coord[i],i)} fills an integer lattice
field @code{coord[i]} with a value on each site equal to the integer
value of the @emph{i}th space-time coordinate on that site.


@node Naming Conventions for Data Parallel Functions, Creating and destroying lattice fields, Layout utilities, QDP Functions
@section Naming Conventions for Data Parallel Functions

Data parallel functions are described in detail in @ref{Function Details}.
Here we desribe the naming conventions.
Data parallel function names are constructed with a pattern that suggests
their functionality.
Thus the function

@code{QDP_V_eq_M_times_V(c, u, b, s);}

carries out the product

@code{c[x] = u[x]*b[x];}

for all lattice coordinates @code{x} belonging to the subset @code{s}.
where @emph{c} and @emph{b} are pointers to lattice staggered fermion vector
fields and @emph{u} is a pointer to a lattice color matrix field.
The elements of the function name are separated by an underscore
(@code{_}) for readability.
All function names in this interface begin with @code{QDP}.
The specific name continues with a precision and color label
as in @code{QDP_F3_V_eq_M_times_V} for single precision @emph{SU(3)}.
Then comes a string of elements that mimics the algebraic expression.
The next character @code{V} abbreviates the type for the destination
operand, in this case the argument @code{c}.
The abbreviations are listed in @ref{Datatypes}.
The next string @code{eq} specifies the assignment operator.
In this case it is a straight replacement, but modifications are also
supported, as described below.
Then comes the first rhs operand type @code{M} followed by a string
@code{times} specifying the operation and a character @code{V}
specifying the second rhs operand type.

Supported variants of the assignment operator are tabulated below.

@multitable @columnfractions .2 .13
@hline
@item Abbreviation @tab Meaning
@hline
@item eq           @tab @math{=}
@item peq          @tab @math{+=}
@item meq          @tab @math{-=}
@item eqm          @tab @math{=-}
@hline
@end multitable

Some functions allow all of these and some take only a simple replacement (eq).

@menu
* Constant Arguments::          
* Color argument::              
* Adjoint::                     
* Shift::                       
* Operations on arrays of fields::  
@end menu

@node Constant Arguments, Color argument, Naming Conventions for Data Parallel Functions, Naming Conventions for Data Parallel Functions
@subheading Constant Arguments

In some cases it is desirable to keep an argument constant over the
entire subset.  For example the function

@code{QDP_V_eq_c_times_V(c,z,b,s)}

multiplies a lattice field of color vectors by a complex constant as in

@code{c[x] = z*b[x]}

for @code{x} in subset @code{s}.
In this case we specify that the argument is constant (coordinate-independent)
by writing the type abbreviation in lower case: @code{c}.

@node Color argument, Adjoint, Constant Arguments, Naming Conventions for Data Parallel Functions
@subheading Color argument for @emph{SU(N)}

For the general color case @emph{SU(N)} the specific function requires an
extra argument giving the number of colors.  It always comes first.
Thus in the above example we would write

@code{QDP_FN_V_eq_c_times_V(nc, c, z, b, s);}

where @code{nc} specifies the number of colors.  In normal practice,
the variable @code{nc} should be replaced by the required user-defined
macro @qdpNcMacro specifying the prevailing number of colors.  The
generic function is actually a macro and is automatically converted to
this usage with @qdpNcMacro for the first argument.  However, if the
specific name is used, the user must supply the argument.

@node Adjoint, Shift, Color argument, Naming Conventions for Data Parallel Functions
@subheading Adjoint

The adjoint of an operand is specified by a suffix @code{a} after the
type abbreviation.  Thus

@code{QDP_V_eq_Ma_times_V(c, u, b, s);}

carries out the product

@code{c[x] = adjoint(u[x])*b[x];}

for all sites @code{x} in subset @code{s}.

@node Shift, Operations on arrays of fields, Adjoint, Naming Conventions for Data Parallel Functions
@subheading Shift

A shift in an operand is specified by a prefix lowercase @code{s} before
the type abbreviation.  (See the discussion of shifts below.) Thus

@code{QDP_V_eq_sV(c, b, dir, sign, s);}

shifts staggered fermion data along the direction specified by @code{dir}
and @code{sign} for all sites @code{x} in destination subset @code{s}.

@node Operations on arrays of fields,  , Shift, Naming Conventions for Data Parallel Functions
@subheading Operations on arrays of fields

Some of the routines can operate on multiple fields at a time.
These functions are designated by placing a @code{v} in front of the
@emph{eqop} operator.  The allowed @emph{eqop}'s are then
@code{veq}, @code{vpeq}, @code{vmeq} and @code{veqm}.
All arguments to the function are then made into arrays of the type
the original argument was @emph{except} for the subset.
Even scalar values (QLA types) and other parameters are turned into arrays.
The length of the arrays is then given as the last argument.
For example the function

@code{QDP_F3_V_peq_M_times_V(QDP_F3_ColorVector *r, QDP_F3_ColorMatrix *a, @*
@ @ @ @ QDP_F3_ColorVector *b, QDP_Subset s );}

@noindent
becomes

@code{QDP_F3_V_vpeq_M_times_V(QDP_F3_ColorVector *r[], QDP_F3_ColorMatrix *a[],
@* @ @ @ @ QDP_F3_ColorVector *b[], QDP_Subset s, int n );}

@noindent
This has the same effect as the following code

@code{for(i=0; i<n; i++)
QDP_F3_V_peq_M_times_V( r[i], a[i], b[i], s );}

@noindent
however it may be implemented in a more efficient manner
(@pxref{Optimization Calls}).
It is permissible to have multiple array elements point to the same field.
The result will always agree with that of the above @code{for} loop.


@node Creating and destroying lattice fields, Subsets, Naming Conventions for Data Parallel Functions, QDP Functions
@section Creating and destroying lattice fields

All QDP fields are creted and destroyed with the following functions.
The alignment and type of memory (on architectures that support it)
is detrmined by the default alignment and flags (@pxref{Optimization Calls}).

@c @subheading Creating a lattice field
@sfuncte{
Creating a lattice field,
@var{Type} * QDP_create_@var{T},
void,
Creates lattice field of type @var{Type}.,
@allTypes,
u = QDP_create_M();}

In prototype specifications throughout this document the notation
@emph{Type} specifies the generic or specific datatype name matching the
abbreviation @emph{T} according to the table in @ref{Datatypes}.

@c @subheading Destroying a lattice field
@sfuncte{
Destroying a lattice field,
void QDP_destroy_@var{T},
@var{Type} *a,
Frees memory associated with field @code{a}.,
@allTypes,
QDP_destroy_M(u);}


@node Subsets, Shifts, Creating and destroying lattice fields, QDP Functions
@section Subsets

All QDP linear algebra and shift operations require specifying the
subset of the lattice on which the operation is performed.  The subset
may be the entire lattice.  When defining subsets, it is often
convenient to partition the lattice into multiple disjoint subsets
(e.g. time slices or checkerboards).  Such subsets are defined through
a user-supplied function that returns a range of integers
0,1,2,...,n-1 so that if f(x) = i, then site @emph{x} is in
partition @emph{i}.  A single subset may also be defined by limiting the
range of return values to a single value (i.e. 0).  This procedure may
be called more than once, and sites may be assigned to more than one
subset.  Thus, for example an even site may also be assigned to a time
slice subset and one of the subsets in a 32-level checkerboard scheme.
A subset definition remains valid until @code{QDP_destroy_subset} is
called.

@menu
* Defining a subset::           
* Reductions on subsets::       
@end menu

@node Defining a subset, Reductions on subsets, Subsets, Subsets
@subheading Defining a subset

Subsets are defined through the data type @code{QDP_Subset}

@funce{
QDP_Subset * QDP_create_subset,
int (*func)(int x[]@comma{} void *args)@comma{} void *args@comma{}
int argsize@comma{} int n,
Creates an array of @code{n} subsets based on @code{func}.,
QDP_Subset ts[nt];@*
ts = QDP_create_subset(timeslice@comma{} NULL@comma{} 0@comma{} nt);@*
where timeslice(x@comma{} NULL) returns x[3]}

The extra arguments @code{args} are passed directly to the function and saved
in case the subset function is needed again when doing shifts involving the
subset.  Therefore the function should not depend on any other global
parameters that may change later in the program.
It is permissible to call @code{QDP_create_subset} with n = 1.
In this case the function must return zero if the site is in the
subset and nonzero if not.  (Note, this is opposite the @emph{true},
@emph{false} convention in C).

@c @subheading Destroying subsets
@sfunce{
Destroying subsets,
void QDP_destroy_subset,
QDP_subset s[],
Destroys all subsets created with @code{s}.,
QDP_destroy_subset(ts);}

This procedure frees all memory associated with the subset object @emph{s}.
The @code{QDP_subset *} value @emph{s} should be the object
returned by @code{QDP_create_subset}.  All subsets in the array
@emph{s} are destroyed.

@sfunc{
Getting the size of a subset,
int QDP_subset_len,
QDP_subset s,
Returns the number of sites in a subset.}


@node Reductions on subsets,  , Defining a subset, Subsets
@subheading Reductions on subsets

Reduction operations (norms, inner products, global sums) come in two
variants according to whether the result is computed on a single
subset of the lattice or on multiple subsets.  Thus the operation

@example
  QLA_Complex z;
  QDP_ColorVector *a, *b;
  QDP_c_eq_V_dot_V(&z, a, b, QDP_even);
@end example

sums the dot product of the lattice staggered fermion fields @emph{a}
and @emph{b} on the even sites and stores the result in @emph{z}.
The operation

@example
  QLA_Complex z[nt];
  QDP_ColorVector *a, *b;
  QDP_c_eq_V_dot_V_multi(z, a, b, ts, nt);
@end example

with the timeslice subsets illustrated above computes the dot product
summed separately on each timeslice and stores the sums in the array
@emph{z}, so that the value in @emph{z[i]} results from the sum on the
subset @emph{ts[i]}.

@node Shifts, I/O utilities, Subsets, QDP Functions
@section Shifts

Shifts are general communication operations specified by any
permutation of sites.  Nearest neighbor shifts are a special case and
are preinitialized by @code{QDP_initialize}. Arbitrary displacement
shifts are an intermediate generalization and are created with
@code{QDP_create_shift}.  Arbitrary permutations are created with
@code{QDP_create_map}.  However they are created, all shifts are
specified by a @emph{direction} label @emph{dir} of type @code{QDP_Shift}
and a sign @emph{sign} of type @code{QDP_ShiftDir} that takes one of two
predefined values @code{QDP_forward} and @code{QDP_backward}.

Shifts are treated syntactically as a modification of a QDP argument
and are specified with a prefix @emph{s} before the type abbreviation
for the shifted field. Thus, for example,

@code{QDP_H_eq_sH(r, a, dir, sign, s);}

@noindent
shifts the half fermion field @emph{a} along direction @emph{dir}, forward or
backward according to @emph{sign}, placing the result in the field @emph{r}.
Nearest neighbor shifts are specified by values of the global shift
@code{QDP_neighbor[mu]} with @code{mu} in the range [0, Ndim-1].
The sign is @code{QDP_forward} for shifts from the positive direction, and
@code{QDP_backward} for shifts from the negative direction.  That is,
for @code{QDP_forward} and @code{dir = QDP_neighbor[mu]}, r(x) = a(x+mu).
For more general shifts, the direction @emph{dir} is specified by the object
returned by @code{QDP_create_shift} or @code{QDP_create_map} and @emph{sign}
must be either @code{QDP_forward} or @code{QDP_backward} to specify the
permutation or its inverse, respectively.

The subset restriction applies to the destination field @emph{r}.
Thus a nearest neighbor shift operation specifying the even subset shifts
odd site values from the source @emph{a} and places them on even site
values on the destination field @emph{r}.

@menu
* Creating displacement shifts::  
* Creating arbitrary permutations::  
* Destroying a shift::          
@end menu

@node Creating displacement shifts, Creating arbitrary permutations, Shifts, Shifts
@subheading Creating displacement shifts

@funce{
QDP_Shift QDP_create_shift,
int d[],
Creates a shift defined by the displacement vector @code{d}.,
int d[4] = @{0@comma{}1@comma{}2@comma{}0@};@*
QDP_Shift knight[4][4];@*
knight[2][3] = QDP_create_shift(d);}

The displacement vector points from the recieving site towards the sender
(or the opposite if later used with the @code{QDP_backward} direction).
Calling with a displacement vector @{1,0,0,0@} would reproduce
the shift @code{QDP_neighbor[0]}.

@node Creating arbitrary permutations, Destroying a shift, Creating displacement shifts, Shifts
@subheading Creating arbitrary permutations

@funce{
QDP_Shift QDP_create_map,
void *(func*)(int rx[Nd]@comma{} int sx[Nd]@comma{} QDP_ShiftDir fb@comma{} void *args)@comma{}
void *args@comma{} int argsize,
Creates a shift specified by the permutation map @code{func}.,
int mu = 1;@*
QDP_Shift mirror[4];@*
mirror[mu] = QDP_create_map(reflect@comma{} &mu@comma{} sizeof(mu));@*
where reflect(rx@comma{}sx@comma{}QDP_forward@comma{}mu) sets sx[i] = rx[i] except for sx[mu] = L[mu] - 1 - rx[mu].}

The return value is used in the various linear
algebra calls involving shifts.  The arguments @emph{args} are passed
through to the calling function.  The @emph{argsize} parameter
specifies the byte length of the argument array or structure.

The implementation may choose to postpone construction of a shift.
Thus it is required that the callback function @emph{func} be static
and invariant, i.e. a function call with the same arguments must give
the same result, even if the call is postponed.
The parameters @emph{args} are copied at the moment the shift is created,
however, so they may be volatile.
The size argument @emph{argsize} makes copying possible.

@node Destroying a shift,  , Creating arbitrary permutations, Shifts
@subheading Destroying a shift

The corresponding destruction function is @code{QDP_destroy_shift}.

@funce{
void QDP_destroy_shift,
QDP_Shift shift,
Frees memory associated with the map @emph{shift}.,
QDP_destroy_shift(shift);}

@node I/O utilities, Temporary entry and exit from QDP, Shifts, QDP Functions
@section I/O utilities

QDP provides a convenient interface to the QIO library which can read
and write any lattice field in the SciDAC format including ILDG lattices.
It also provides routines for inserting metadata and global binary data
into the files.

@menu
* Opening and closing binary files::  
* Reading and writing QDP fields::  
* Reading and writing QLA arrays::  
* String Handling::             
@end menu

@node Opening and closing binary files, Reading and writing QDP fields, I/O utilities, I/O utilities
@subsection Opening and closing binary files

As with standard Unix, a file must be opened before reading or
writing.  However, we distinguish file handles for both cases.
@c If the system provides a parallel file system, it is possible for several
@c processors to read and write a single file. We call this mode
@c @emph{parallel}.  Otherwise the file is read by a single processor and
@c the data delivered according to the distributed memory layout.  The
@c reverse occurs upon writing. We call this mode @emph{serial}. To allow
@c user choice where the architecture permits, we provide for requesting
@c either mode.  However, the request may be overridden if the system
@c permits only one mode.  Upon writing, we allow appending to an
@c existing file.

@c @subsubsection{Open a file for reading}
@ssfunce{
Open a file for reading,
QDP_Reader *QDP_open_read,
QDP_String *md@comma{} char *filename,
Opens a named file for reading and reads the file metadata.,
QDP_Reader *infile;@*
QDP_String *file_xml = QDP_string_create();@*
infile = QDP_open_read(file_xml@comma{} filename);
}

The @code{QDP_Reader} return value is the file handle used in
subsequent references to the file.  A null return value signals an
error. The I/O system takes responsibility for allocating and freeing
space for the handle.  It is assumed the user has preperly created the
@code{QDP_String} that will hold the file metadata
so it can be read from the head of the file and inserted.
@c The other arguments have the same meaning as with \verb|QDP_open_write|.
The volume format (see @code{QDP_open_write} below) is autodetected,
 so is not specified.

@c @subsubsection{Open a file for writing}
@ssfunce{
Open a file for writing,
QDP_Writer *QDP_open_write,
QDP_String *md@comma{} char *filename@comma{} int volfmt,
Opens a named file for writing and writes the file metadata.,
QDP_Writer *outfile;@*
QDP_String *file_xml = QDP_string_create();@*
QDP_string_set(file_xml@comma{} xml_string);@*
outfile = QDP_open_write(file_xml@comma{} filename@comma{} QDP_SINGLEFILE);
}

The @code{QDP_Writer} return value is the file handle used in
subsequent references to the file.  A null return value signals an
error. The I/O system takes responsibility for allocating and freeing
space for the handle.  It is assumed the user has already created the
file metadata in @code{file_xml}, so it can be written
at the head of the file.  The @code{volfmt} argument is either
@code{QDP_SINGLEFILE} or @code{QDP_MULTIFILE}.
@code{QDP_SINGLEFILE} creates a single file for the output from all nodes
while @code{QDP_MULTIFILE} creates one file per node.

@c @subsubsection{Close an input file}
@ssfunce{
Close an input file,
int QDP_close_read,
QDP_Reader *reader,
Closes an input file.,
QDP_close_read(reader);
}

@c @subsubsection{Close an output file}
@ssfunce{
Close an output file,
int QDP_close_write,
QDP_Writer *writer,
Closes an output file.,
QDP_close_write(writer);
}

In both cases the integer return value is 0 for success and 1 for failure.

@node Reading and writing QDP fields, Reading and writing QLA arrays, Opening and closing binary files, I/O utilities
@subsection Reading and writing QDP fields

@*

@c @subsubsection{Reading a field}
@ssfuncte{
Reading a field,
int QDP_read_@var{T},
QDP_Reader *in@comma{} QDP_String *record_xml@comma{} QDP_@var{Type} *field,
Reads the field and its metadata from the next record in the specified file.,
@allTypes,
QDP_Real *field = QDP_create_R();@*
QDP_read_R(reader@comma{} record_xml@comma{} field);
}

The integer return value is 0 for success and 1 for failure.  It is
assumed the user has created the @code{QDP_String} for the record metadata
and the field for the data in advance. 
The datatype of the record must match the field type.

@c @subsubsection{Reading an array of fields}
@ssfuncte{
Reading an array of fields,
int QDP_vread_@var{T},
QDP_Reader *in@comma{} QDP_String *record_xml@comma{} QDP_@var{Type} *field[]@comma{} int n,
Reads the array of fields and its metadata from the next record in the specified file.,
@allTypes,
QDP_ColorMatrix *field[4];@*
for(i=0; i<4; i++) field[i] = QDP_create_M();@*
QDP_vread_M(reader@comma{} record_xml@comma{} field@comma{} 4);
}

The integer return value is 0 for success and 1 for failure.  It is
assumed the user has created the @code{QDP_String} for the record metadata
and the fields for the data in advance.

@subsubheading Reading only the record information

It may be convenient to examine the record metadata first to decide whether
to read or skip the accompanying binary data.

@funce{
int QDP_read_record_info,
QDP_Reader *in@comma{} QIO_RecordInfo *record_info@comma{} QDP_String *record_xml,
Reads the record info and/or metadata from the next record in the specified file.  Either of record_info or record_xml can be NULL in which case it is ignored.,
QDP_read_record_info(reader@comma{} record_info@comma{} record_xml);
}

A subsequent call to @code{QDP_read_}@var{T} returns a copy of the same
metadata along with the lattice field.

@c @subsubsection{Skipping to the next record}
@ssfunce{
Skipping to the next record,
int QDP_next_record,
QDP_Reader *in,
Advances to the beginning of the next record.,
QDP_next_record(reader);
}

@c @subsubheading{Writing a field}
@ssfuncte{
Writing a field,
int QDP_write_@var{T},
QDP_Writer *out@comma{} QDP_String *record_xml@comma{} QDP_@var{Type} *field,
Writes the field and its metadata as the next record in the specified file.,
@allTypes,
QDP_Real *field = QDP_create_R();@*
QDP_R_eq_zero(field@comma{} QDP_all);@*
QDP_write_R(writer@comma{} record_xml@comma{} field);
}

The integer return value is 0 for success and 1 for failure.  It is
assumed the user has created the @code{QDP_String} for the record metadata
and the array for the data in advance.

@c @subsubheading{Writing an array of fields}
@ssfuncte{
Writing an array of fields,
int QDP_write_v@var{T},
QDP_Writer *out@comma{} QDP_String *record_xml@comma{} QDP_@var{Type} *field[]@comma{} int n,
Writes the array of fields and its metadata as the next record in the specified file.,
@allTypes,
QDP_ColorMatrix *field[4];@*
for(i=0; i<4; i++) field[i] = QDP_create_M();@*
for(i=0; i<4; i++) QDP_M_eq_zero(field[i]@comma{} QDP_all);@*
QDP_write_vM(writer@comma{} record_xml@comma{} field@comma{} 4);
}

The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared the record metadata and the array data
in advance.

@node Reading and writing QLA arrays, String Handling, Reading and writing QDP fields, I/O utilities
@subsection Reading and writing QLA arrays

QLA data is global data that carries no lattice site index.
Typically these values result from a global reduction. For example, a
correlation function might be computed on every time slice of the
lattice and summed globally over the entire machine.  From the
standpoint of data parallel I/O operation the data is treated as a
global quantity with the same name and value on every processor.  When
it is written to a file, it is assumed that the values are the same on
each node, so only one node needs to write its value.  When it is read
from a file, the I/O system does a broadcast to every node, so the
result of reading is a global value.

An interface is provided for reading and writing arrays of QLA data.
Single QLA values can be passed as an array of length one.  The naming
conventions for the routines follow conventions of the QDP API.
Notice that the encoded QLA data type is lower case and the argument is a
pointer to a QLA type.

@c subsubheading{Reading a QLA array}
@ssfuncte{
Reading a QLA array,
int QDP_vread_@var{t},
QDP_Reader *in@comma{} QDP_String *record_xml@comma{} QLA_@var{Type} *array@comma{} int n,
Reads the QLA array and its metadata from the next record in the specified file.,
@allTypes,
QLA_Complex array[nt];@*
QDP_vread_c(reader@comma{} record_xml@comma{} array@comma{} nt);
}

The integer return value is 0 for success and 1 for failure.  It is
assumed the user has created the record metadata and the
field data in advance.

@c subsubheading{Writing an array of QLA values}
@ssfuncte{
Writing an array of QLA values,
int QDP_write_v@var{t},
QDP_Writer *out@comma{} QDP_String *record_xml@comma{} QLA_@var{Type} *array@comma{} int n,
Writes the QLA array and its metadata as the next record in the specified file.,
@allTypes,
QLA_Complex array[nt];@*
QDP_c_eq_V_dot_V_multi(array@comma{} prop@comma{} src@comma{} timeslices@comma{} nt);@*
QDP_write_vc(writer@comma{} record_xml@comma{} array@comma{} nt);
}

The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared the record metadata and the field data
in advance.


@node String Handling,  , Reading and writing QLA arrays, I/O utilities
@subsection String Handling

The file and record metadata is passed to QDP in @code{QDP_string} objects.
These can be created, destroyed and converted to/from C strings with
the following routines.

@c @subsubheading{Creating an empty QDP string}
@ssfunce{
Creating an empty QDP string,
QDP_String *QDP_string_create,
void,
Creates an empty string.,
fileinfo = QDP_string_create();
}

@c @subsubheading{Destroying a QDP string}
@ssfunce{
Destroying a QDP string,
void QDP_string_destroy,
QDP_String *xml,
Frees the @code{QDP_string} object and its contents.,
QDP_string_destroy(xml);
}

@c @subsubheading{Set a QDP string from a C string}
@ssfunce{
Set a QDP string from a C string,
void QDP_string_set,
QDP_String *qstring@comma{} char *cstring,
Sets the QDP string to contain a copy of the null-terminated character array @code{cstring}.,
QDP_string *fileinfo = QDP_string_create();@*
QDP_string_set(fileinfo@comma{} string);
}

@c @subsubheading{Copying a QDP string}
@ssfunce{
Copying a QDP string,
void QDP_string_copy,
QDP_String *dest@comma{} QDP_String *src,
Copies the string.,
QDP_string_copy(newxml@comma{} oldxml);
}

@c @subsubheading{Accessing the string length}
@ssfunce{
Accessing the string length,
size_t QDP_string_length,
QDP_String *qs,
Returns the length of the string.,
length = QDP_string_length(xml);
}

@c @subsubheading{Accessing the character string}
@ssfunce{
Accessing the character string,
char *QDP_string_ptr,
QDP_String *qs,
Returns a pointer to the null-terminated character array in the string.,
printf("%s\n"@comma{} QDP_string_ptr(xml));
}


@node Temporary entry and exit from QDP, Optimization Calls, I/O utilities, QDP Functions
@section Temporary entry and exit from QDP

For a variety of reasons it may be necessary to remove data from QDP
structures.  Conversely, it may be necessary to reinsert data into QDP
structures.  For example, a highly optimized linear solver may
operate outside QDP.  The operands would need to be extracted from QDP
fields and the eventual solution reinserted.  It may also be useful to
suspend QDP communications temporarily to gain separate access to the
communications layer.  For this purpose function calls are provided to
put the QDP implementation and/or QDP objects into a known state,
extract values, and reinsert them.

@c @subheading Exposing QDP data
@sfuncte{
Exposing QDP data,
@var{QLA_Type} * QDP_expose_@var{T},
@var{Type} *src,
Deliver data values from field @code{src}.,
@allNumericTypes,
r = QDP_expose_M(a);}

This function grants direct access to the data values contained in the
QDP field @emph{src}.  The return value is a pointer to an array of QLA
data @emph{dest} of type @emph{T}.  The order of the data is given by
@code{QDP_index}.  No QDP operations are permitted on exposed
data until @code{QDP_reset} is called. (See next.)

@c @subheading Returning control of QDP data
@sfuncte{
Returning control of QDP data,
void QDP_reset_@var{T},
@var{Type} *field,
Returns control of data values to QDP.,
@allNumericTypes,
QDP_reset_M(r);}

This call signals to QDP that the user is ready to resume QDP
operations with the data in the specified field.

@c @subheading Extracting QDP data
@sfuncte{
Extracting QDP data,
void QDP_extract_@var{T},
@var{QLA_Type} *dest@comma{} @var{Type} *src,
Copy data values from field @code{src} to array @code{dest}.,
@allNumericTypes,
QDP_extract_M(r@comma{} a@comma{} QDP_even);}

The user must allocate space of size
@code{QDP_sites_on_node*sizeof(QLA_Type)} for the destination array
before calling this function, regardless of the size of the subset.
This function copies the data values contained in the QDP field @emph{src}
to the destination field.  Only values belonging to the specified
subset are copied.  Any values in the destination array not associated
with the subset are left unmodified.  The order of the data is given
by @code{QDP_index}.  Since a copy is made, QDP operations
involving the source field may proceed without disruption.

@c @subheading Inserting QDP data
@sfuncte{
Inserting QDP data,
void QDP_insert_@var{T},
@var{Type} *dest@comma{} @var{QLA_Type} *src,
Inserts data values from QLA array @code{src}.,
@allNumericTypes,
QDP_insert_M(a@comma{} r);}

Only data associated with the specified subset are inserted.
Other values are unmodified.  The data order must conform to
@code{QDP_index}.  This call, analogous to a fill operation, is
permitted at any time and does not interfere with QDP operations.

@c @subheading Extracting QDP data to a packed array
@sfuncte{
Extracting QDP data to a packed array,
void QDP_extract_packed_@var{T},
@var{QLA_Type} *dest@comma{} @var{Type} *src,
Copy data values from field @code{src} to array @code{dest}.,
@allNumericTypes,
QDP_extract_M(r@comma{} a@comma{} QDP_even);}

The user must allocate space of size
@code{QDP_subset_len(subset)*sizeof(QLA_Type)} for the destination array
before calling this function.
This function copies the data values contained in the QDP field @emph{src}
to the destination field.  Only values belonging to the specified
subset are copied and they are stored contiguously in the destination array.
The order of the data is given
by @code{QDP_index}.  Since a copy is made, QDP operations
involving the source field may proceed without disruption.

@c @subheading Inserting QDP data from a packed array
@sfuncte{
Inserting QDP data from a packed array,
void QDP_insert_packed_@var{T},
@var{Type} *dest@comma{} @var{QLA_Type} *src,
Inserts data values from QLA array @code{src}.,
@allNumericTypes,
QDP_insert_M(a@comma{} r);}

Only data associated with the specified subset are inserted.
Other values are unmodified.  The data order must conform to
@code{QDP_index}.  This call, analogous to a fill operation, is
permitted at any time and does not interfere with QDP operations.

@subheading Suspending QDP communications

If a user wishes to suspend QDP communications temporarily and carry
on communications by other means, it is first necessary to call
@code{QDP_suspend_comm}.

@funce{
void QDP_suspend_comm,
void,
Suspends QDP communications.,
QDP_suspend_comm();}

No QDP shifts can then be initiated until @code{QDP_resume} is called.
However QDP linear algebra operations without shifts may proceed.

@subheading Resuming QDP communications

To resume QDP communications one uses

@funce{
void QDP_resume_comm,
void,
Restores QDP communications.,
QDP_resume_comm();}

@node Optimization Calls,  , Temporary entry and exit from QDP, QDP Functions
@section Optimization Calls

The following procedures are included to aid in optimization of the
QDP implementation

@c @subheading Marking discarded data
@sfuncte{
Marking discarded data,
void QDP_discard_@var{T},
@var{Type} *a,
Indicates data in @code{a} is no longer needed.,
@allNumericTypes,
QDP_discard_M(utemp);}

The field is not destroyed and memory is not released.  For that
purpose, see @code{QDP_destroy}.  This call allows the implementation
to ignore the data dependency that may have been created from a shift
which allows the shift to be efficiently reused later.
It is a runtime error to attempt to use discarded data as an rvalue
(source operand or incremented destination) in any subsequent operation.
However, once the field is used as an lvalue (fully replaced destination),
data integrity is automatically reinstated.

This should be called on the result of a shift once the result is no longer
needed.
It is safe to call it for any field as long as the data is no longer needed.
It is highy recommended for the sake of efficiency that one always call
this as soon as the result of a shift is no longer needed.
It can also be used to make sure that a field is not being used elsewhere
without first being set since using a discarded field without first setting it
produces an error.

@c @subheading{Block size operations}
@sfunc{
Block size operations,
int QDP_get_block_size,
void,
Returns the block size.
}

@func{
void QDP_set_block_size,
int bs,
Sets the block size.
}

These functions allow one to set the block size used for the operations
on arrays of QDP fields.  Instead of running over all sites of each field
individually, it can run over a few sites for each field in turn and then
move to the next few sites on each field and so on until all sites are done.
The number of sites done at a time is determined by the block size.

@c @subheading{Memory alignment}
@sfunc{
Memory alignment,
int QDP_get_mem_align,
void,
Returns the default memory alignment.
}

@func{
void QDP_set_mem_align,
int align,
Sets the default memory alignment.
}

Some architectures might perform better for fields with certain alignments.
This allows one to set the default alignment used when fields are created.
It only affects newly created fields.
Currently the default is set to 16 bytes if not set by the user which
should be sufficient for most current platforms.
It is expected that the QDP library will automatically use whatever value
is necessary to utilize the optimized QLA routines for architectures
which QLA has been optimized for.
Therefore the user normally would not need to set this and it is recommended
that they don't unless they specifically find it useful for a platform
not already optimized in QLA.
The user can also use the macro @code{QDP_ALIGN_DEFAULT} to specify the
default alignment provided by QMP for that machine.

@c @subheading{Memory attributes}
@sfunc{
Memory attributes,
int QDP_get_mem_flags,
void,
Returns the default memory flags
}

@funce{
void QDP_set_mem_flags,
int flags,
Sets the default memory flags,
QDP_set_mem_flags(QDP_MEM_FAST|QDP_MEM_COMMS);
}

This allows the user to set the characteristics of the memory used for
newly created fields if the architecture supports them.
The QDP memory flags have the same meaning as the corresponding QMP flags.
The integer value is the combination (bitwise or) of the flags given below.
The actual effect of each combination is specific to the implementation and
the architecture.

@multitable @columnfractions .3 .7
@hline
@item Memory Flag    @tab Meaning
@hline
@item QDP_MEM_NONCACHE @tab Use noncached memory.
@item QDP_MEM_COMMS    @tab Use memory that is optimized for communucations.
@item QDP_MEM_FAST     @tab Use fastest memory available (such as EDRAM on QCDOC).
@item QDP_MEM_DEFAULT  @tab Use default value for architecture (from QMP).
@hline
@end multitable


@macro functionhookfills
@c @subheading Function fills
@sfunct{
Function fills,
QDP_@var{T}_eq_func,
@var{Type} *r@comma{} void (*func)(@var{QLA_Type} *dest@comma{} int coords[])@comma{} @var{subset},
calls func(&r[x]@comma{} x) for all coordinates x in subset,
I@comma{} R@comma{} C@comma{} V@comma{} H@comma{} D@comma{} M@comma{} P}
@sfunct{
Function fills,
QDP_@var{T}_eq_funci,
@var{Type} *r@comma{} void (*func)(@var{QLA_Type} *dest@comma{} int index)@comma{} @var{subset},
calls func(&r[x]@comma{} index(x)) for all coordinates x in subset,
I@comma{} R@comma{} C@comma{} V@comma{} H@comma{} D@comma{} M@comma{} P}
@*
@end macro

@macro functionhookunary
@end macro

@macro functionhooktype
@end macro

@macro functionhookbinary
@end macro

@macro functionhookternary
@end macro

@macro functionhookboolean
@end macro

@c ====================================================================
@node     Function Details,  , QDP Functions, Top
@chapter  Function Details
@c ====================================================================

This section describes in some detail the names and functionality for
all functions in the interface involving linear algebra with and
without shifts.  Because of the variety of datatypes, and assignment
operations, there are a few hundred names altogether.  However, there
are only a couple dozen categories.  It is hoped that the construction
of the names is sufficiently natural that with only a little practice,
the user can guess the name of any function and determine its
functionality without consulting a list.

In prototype specifications throughout this document the notation
@var{Type} specifies the generic or specific datatype name matching
the abbreviation @var{T} according to the table in @ref{Datatypes}.
We also introduce the shorthand

@c @code{#typedef const QDP_Subset Subset}
@code{#define @var{subset} QDP_Subset subset}

Unless otherwise indicated, operations occur on all sites in the
specified subset.

@menu
* Functions involving shifts::  
* Fills and random numbers::
* Unary Operations::
* Type conversion and component extraction and insertion::
* Binary operations with constants::
* Binary operations with fields::
* Ternary operations with fields::
* Boolean operations::
* Reductions::
@end menu

@node Functions involving shifts,  , Function Details, Function Details
@section Functions involving shifts

@c @subheading Shifting
@sfuncvt{
Shifting,
QDP_@var{T}_eq_s@var{T},
@var{Type} *r@comma{} @var{Type} *a@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
QDP_@var{T}_veq_s@var{T},
@var{Type} *r[]@comma{} @var{Type} *a[]@comma{} QDP_Shift s[]@comma{} QDP_ShiftDir d[]@comma{} @var{subset}@comma{} int n,
r = shift(a),
I@comma{} R@comma{} C@comma{} V@comma{} H@comma{} D@comma{} M@comma{} P}

@c @subheading Left multiplication by shifted color matrix
@sfunct{
Left multiplication by shifted color matrix,
QDP_@var{T}_eq_sM_times_@var{T},
@var{Type} *r@comma{} QDP_ColorMatrix *a@comma{} @var{Type} *b@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
r = shift(a) * b,
V@comma{} H@comma{} D@comma{} M@comma{} P}

@c @subheading Left multiplication of shifted field by color matrix
@sfunct{
Left multiplication of shifted field by color matrix,
QDP_@var{T}_eq_M_times_s@var{T},
@var{Type} *r@comma{} QDP_ColorMatrix *a@comma{} @var{Type} *b@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
r = a * shift(b),
V@comma{} H@comma{} D@comma{} M@comma{} P}

@c @subheading Left multiplication by color matrix then shift
@sfunct{
Left multiplication by color matrix then shift,
QDP_@var{T}_eq_sM_times_s@var{T},
@var{Type} *r@comma{} QDP_ColorMatrix *a@comma{} @var{Type} *b@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
r = shift(a * b),
V@comma{} H@comma{} D@comma{} M@comma{} P}

@include functions.texi

@bye
