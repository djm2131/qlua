;; QA0 driver
#fload "sfc.sf"
#fload "common.sf"
#fload "error.ss"
#fload "print.ss"
#fload "cheader.ss"
#fload "backend.ss"
#fload "parser.ss"
#fload "cfold.ss"
#fload "q2complex.ss"
#fload "c2real.ss"
#fload "cx2qh.ss"
#fload "qa0print.ss"
#fload "be-c99.ss"
#fload "be-c99-64.ss"
#fload "be-dry.ss"
#fload "be-bgq-xlc.ss"
;;
;; (provide qa0-driver)
;;
(define qa0-driver
  (let ()
    (define *version* "Version qit tree")
    (define (do-help arg*)
      (for-each (lambda (cdf) (q-print "\t~a\t~a~%" (car cdf) (cadr cdf)))
                cmd*))
    (define (la-compilier arg* machine front back)
      (if (not  (= (vector-length arg*) 4))
          (s-error "bad arguments"))
      (let* ([d/f (vector-ref arg* 1)]
             [output (vector-ref arg* 2)]
             [input (vector-ref arg* 3)]
             [d/f (cond
                   [(string=? d/f "double") 'double]
                   [(string=? d/f "float") 'float]
                   [else (s-error "Unexpected value for d/f: ~a" d/f)])])
        (define (run-me)
          (q-print "/* automagically generated by qa0 ~a */~%" *version*)
          (front input machine d/f back))
        (if (string=? output "-")
            (run-me)
            (begin
              (if (file-exists? output) (delete-file output))
              (with-output-to-file output run-me)))))
    (define (do-header arg*)
      (la-compilier arg* machine-c99-32 qa0-compile c-header))
    (define (do-cee arg*)
      (la-compilier arg* machine-c99-32 qa0-real-compile emit-back-end))
    (define (do-cee-64 arg*)
      (la-compilier arg* machine-c99-64 qa0-real-compile emit-back-end))
    (define (do-c99 arg*)
      (la-compilier arg* machine-c99-32 qa0-compile emit-back-end))
    (define (do-c99-64 arg*)
      (la-compilier arg* machine-c99-64 qa0-compile emit-back-end))
    (define (do-dry arg*)
      (la-compilier arg* machine-dry qa0-compile emit-back-end))
    (define (do-bgq/xlc arg*)
      (la-compilier arg* machine-bgq/xlc qa0-compile emit-back-end))
    (define (print-tree/env ast env) (print-tree ast))
    (define (do-version arg*)
      (q-print "qa0: ~a~%" *version*))
    (define (do-macro arg*)
      (la-compilier arg* machine-c99-32 qa0-macro print-tree/env))
    (define (do-c-expand arg*)
      (la-compilier arg* machine-c99-32 qa0-c-expand print-tree/env))
    (define (do-r-expand arg*)
      (la-compilier arg* machine-c99-32 qa0-r-expand print-tree/env))
    (define (do-qhexpand arg*)
      (la-compilier arg* machine-bgq/xlc qa0-qhexpand print-tree/env))
    (define (qa0-macro name machine d/f back-end)
      (let-values* ([ast (parse-qa0-file name)]
                    [(ast env) (fold-constants/env ast machine d/f)])
        (back-end ast env)))
    (define (qa0-c-expand name machine d/f back-end)
      (qa0-macro name machine d/f
                 (lambda (ast env)
                   (let-values* ([(ast e-x) (qcd->complex ast env)])
                     (back-end ast env)))))
    (define (qa0-r-expand name machine d/f back-end)
      (qa0-macro name machine d/f
                 (lambda (ast env)
                   (let-values* ([(ast e-x) (qcd->complex ast env)]
                                 [(ast e-x) (complex->real ast env)])
                     (back-end ast env)))))
    (define (qa0-dhexpand name machine d/f back-end)
      (qa0-c-expand name machine d/f
                    (lambda (ast env)
                      (let ([ast (complex->double-hummer ast)])
                        (back-end ast env)))))
    (define (qa0-qhexpand name machine d/f back-end)
      (qa0-c-expand name machine d/f
                    (lambda (ast env)
                      (let ([ast (complex->quad-hummer ast)])
                        (back-end ast env)))))
    (define (qa0-compile name machine d/f back-end)
      (qa0-c-expand name machine d/f
                    (lambda (ast env)
                      (let-values* ([(ast env) (complex->back-end ast env)])
                        (back-end ast env)))))
    (define (qa0-real-compile name machine d/f back-end)
      (qa0-c-expand name machine d/f
                    (lambda (ast env)
                      (let-values* ([(ast env) (complex->real ast env)]
                                    [(ast env) (complex->back-end ast env)])
                        (back-end ast env)))))
    (define cmd*
      (list
       (list "help"    "             print available commands"        do-help)
       (list "header"  "d/f out in   build .h file for double/float"  do-header)
       (list "cee-64"  "d/f out in   build .c file for double/float"  do-cee-64)
       (list "cee-32"  "d/f out in   build .c file for double/float"  do-cee)
       (list "cee"     "d/f out in   same as cee-32"                  do-cee)
       (list "c99-64"  "d/f out in   build .c file for double/float"  do-c99-64)
       (list "c99-32"  "d/f out in   build .c file for double/float"  do-c99)
       (list "c99"     "d/f out in   same as c99-32"                  do-c99)
       (list "dry"     "d/f out in   build .c file for dry version"   do-dry)
       (list "bgq/xlc" "d/f out in   build .c file for XLC on BG/Q"   do-bgq/xlc)
       (list "macro"   "d/f out in   do constant folding only"        do-macro)
       (list "complex" "d/f out in   convert to complex only"         do-c-expand)
       (list "real"    "d/f out in   convert to real only"            do-r-expand)
       (list "qhummer" "d/f out in   convert to QH only"              do-qhexpand)
       (list "version" "             print qa0 version"               do-version)))
    (define (dispatch name arg*)
      (let loop ([cmd* cmd*])
        (cond
         [(null? cmd*) (q-print "qa0: Unknown command ~s. Try saying qa0 help~%"
                               name)]
         [(string=? name (caar cmd*)) ((caddar cmd*) arg*)]
         [else (loop (cdr cmd*))])))
    
    (lambda (args)
      (if (zero? (vector-length args))
          (dispatch "help" '#("help"))
          (dispatch (vector-ref args 0) args)))))
    
