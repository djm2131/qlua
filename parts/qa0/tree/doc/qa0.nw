\documentclass[twoside]{article}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\newcommand{\idiv}{\,\mbox{\bf div}\,}
\newcommand{\imod}{\,\mbox{\bf mod}\,}
\newcommand{\iand}{\,\mbox{\bf and}\,}
\newcommand{\ior}{\,\mbox{\bf or}\,}
\newcommand{\ixor}{\,\mbox{\bf xor}\,}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{680pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\title{QA---Register Transfer Language}
\author{Andrew Pochinsky}
\date{Version XXX}

\newcommand{\any}{${}^{*}$}
\newcommand{\oneplus}{${}^{+}$}
\newcommand{\nonterminal}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\is}{&$\rightarrow$&&}
\newcommand{\also}{&&$|$&}
\newcommand{\terminal}[1]{\texttt{#1}}
\newcommand{\nothing}{\terminal{/* nothing */}}
\newenvironment{grammar}{\par\medskip\begin{tabular}{lccl}}{%
\end{tabular}\medskip\par}

\begin{document}
\maketitle
\section{GRAMMAR}
Here we define the grammar for QA. We start with the file level constructs:

\begin{grammar}
\nonterminal{qa0} \is \nonterminal{decl}\any\\
\nonterminal{decl}\is\nonterminal{alias}\\
  \also\nonterminal{constant}\\
  \also\nonterminal{structure}\\
  \also\nonterminal{array}\\
  \also\nonterminal{verbose} \\
  \also\nonterminal{include} \\
  \also\nonterminal{macro definition}\\
  \also\nonterminal{top level repeat}\\
\nonterminal{top level repeat}\is\nonterminal{procedure}\\
  \also\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{top level repeat}\oneplus \terminal{)}\\
\end{grammar}

The \nonterminal{macro defintion} directive defines a hygenic macro.
\begin{grammar}
\nonterminal{macro definition}\is\terminal{(}\terminal{define}
  \terminal{(} \nonterminal{name} \nonterminal{name}\any\terminal{)}
 \nonterminal{code}\oneplus\terminal{)}
\end{grammar} 

The \nonterminal{include} directive inserts the contents of the file into the
input.
\begin{grammar}
\nonterminal{include}\is\terminal{(}\terminal{include} \nonterminal{file}
  \terminal{)}\\
\nonterminal{file}\is\nonterminal{string}
\end{grammar}


The \nonterminal{verbose} directive allows one to include literals into
various outputs:
\begin{grammar}
\nonterminal{verbose}\is\terminal{(}\terminal{verbose}
   \nonterminal{verbose case}\oneplus\terminal{)} \\
\nonterminal{verbose case}\is\terminal{(}
   \nonterminal{target} \nonterminal{verbose value} \terminal{)} \\
\nonterminal{target}\is\nonterminal{symbol}\\
\nonterminal{verbose data}\is\nonterminal{string}
\end{grammar}
The \nonterminal{target} selects the back-end that will see the corresponding
\nonterminal{vebose data}.

There are two kinds of iterators. One is an enumeration, another is loop-like
\begin{grammar}
\nonterminal{iterator}\is\terminal{(}
   \nonterminal{name} \terminal( \nonterminal{a-value}\oneplus \terminal)
     \terminal{)}\\
  \also\terminal{(}
   \nonterminal{name} \nonterminal{inclusive constant low}
      \nonterminal{exclusive constant high} \terminal{)}\\
\nonterminal{inclusive constant low}\is\nonterminal{constant expr}\\
\nonterminal{exclusive constant high}\is\nonterminal{constant expr}\\
\end{grammar}

Integer constants may be defined and given names. We do not specify the
allowed set of operations in \nonterminal{c-expr} here,
they will be introduced as needed.

\begin{grammar}
\nonterminal{constant}\is\terminal{(} \terminal{constant}
 \nonterminal{name} \nonterminal{constant expression}\terminal{)}\\
\nonterminal{constant expression}\is\terminal{(} \terminal{const}
  \nonterminal{c-expr} \terminal{)}\\
\nonterminal{c-expr}\is\nonterminal{number}\\
  \also\nonterminal{name}\\
  \also\nonterminal{string}\\
  \also\terminal{(} \nonterminal{c-op} \nonterminal{c-expr}\any\terminal{)}\\
\nonterminal{c-op}\is\nonterminal{symbol}\\
\nonterminal{name}\is\nonterminal{symbol}\\
\end{grammar}

Structure definitions provide a way to compute offsets to various elements
within a memory block. They also contain enough information to generate a
corresponding C declaration.

\begin{grammar}
\nonterminal{structure}\is\terminal{(} \terminal{structure}
 \nonterminal{external name}
   \terminal{(}\nonterminal{field}\oneplus\terminal{)}\terminal{)}\\
\nonterminal{field}\is\terminal{(} \nonterminal{external name}
  \nonterminal{type name} \terminal{)}\\
\nonterminal{external name}\is\nonterminal{name} \nonterminal{string}\\
\nonterminal{type name}\is\nonterminal{name}\\
\end{grammar}

Each \nonterminal{structure} definition provides the following set of
\nonterminal{c-expr}. First, there is \terminal{(size-of}
\nonterminal{structure name}\terminal{)} which computes the size
of the structure in bytes. It properly handles all alignment requirements for
parts of the structure and produces the same result as
\verb|sizeof (struct foo)| in C where \verb|foo| is the corresponding C tag.
Second, there is \terminal{(align-of} \nonterminal{structure name}\terminal{)}
computing the alignment of the structure in bytes. It is always a power of 2.
In addition, for each component of the structure, there is 
\terminal{(offset-of} \nonterminal{structure name}
\nonterminal{field name}\terminal{)}, which computes an offset from the
begining of the structure to the given field.

Array types are introduced with the following contruct:
\begin{grammar}
\nonterminal{array}\is\terminal{(} \terminal{array}
 \nonterminal{external name} \nonterminal{base type name}
     \nonterminal{constant expression}\terminal{)}\\
\nonterminal{base type name}\is\nonterminal{type name}
\end{grammar}

There is also a set of predefined types. At this stage we do not specify
them.

Constants, predefined types, arrays, and structures may be aliased. For
simplicity, we do not keep separate name spaces for them. All definitions are
checked for conflicts.
\begin{grammar}
\nonterminal{alias}\is\terminal{(} \terminal{alias}
 \nonterminal{new name} \nonterminal{old name}\terminal{)}\\
\nonterminal{new name}\is\nonterminal{name}\\
\nonterminal{old name}\is\nonterminal{name}\\
\end{grammar}

The last part of the top level structure is procedure. At this time we only
define leaf procedures. Since we need to generate multiple variants of the
procedures from the same sources, external names are generated from the
attributes. The internal names are not used in this version.

\begin{grammar}
\nonterminal{procedure}\is\terminal{(} \terminal{procedure}
  \nonterminal{name} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{argument}\any \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{argument}\is\terminal{(}
    \nonterminal{argument name} \nonterminal{type name}
    \nonterminal{C type} \nonterminal{C name} \terminal{)}\\
\nonterminal{argument name}\is\nonterminal{name}\\
\nonterminal{C type}\is\nonterminal{string}\\
\nonterminal{C name}\is\nonterminal{string}\\
\nonterminal{attribute}\is\nonterminal{name}\\
  \also\terminal{(} \nonterminal{name}
                  \nonterminal{a-value}\oneplus \terminal{)}\\
\nonterminal{a-value}\is\nonterminal{string}\\
   \also\nonterminal{number}\\
   \also\nonterminal{symbol}\\
\end{grammar}

The code is design to help with instruction generation and data flow analysis.
At this stage we keep regular loops and provide conditional branching. There is
no back branches or returns. We do not provide automatic variables since
there are only leaf procedures.

\begin{grammar}
\nonterminal{code}\is \nonterminal{operation}\\
  \also\nonterminal{memory access}\\
  \also\nonterminal{block}\\
  \also\nonterminal{loop}\\
  \also\nonterminal{conditional}\\
  \also\nonterminal{macro call}\\
  \also\nonterminal{inner repeat}\\
\nonterminal{inner repeat}\is\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

To insert the body of \nonterminal{macro definition}, one provides arguments
to the \nonterminal{macro call} form. All registers used as outputs in the body
of the definition will be renamed thus providing hygenic semantics of macro
substitution. There is no syntactic distinction between inputs and outputs in
the call parameters.
\begin{grammar}
\nonterminal{macro call}\is\terminal{(}\terminal{macro}
 \nonterminal{name} \nonterminal{macro input}\any\terminal{)}\\
\nonterminal{macro input}\is
  \terminal{(}\terminal{macro} \nonterminal{name}\terminal{)}\\
  \also\nonterminal{input}
\end{grammar}
The \terminal{macro} form of the macro argument is used to pass macros by name.

Operations modify only their outputs and depends only on their inputs. The
name space of the opcodes is open-ended, the attributes are specific for each
opcode.

\begin{grammar}
\nonterminal{operation}\is\terminal{(} \terminal{op}
  \nonterminal{opcode} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{output}\oneplus \terminal{)}
  \terminal{(} \nonterminal{input}\any \terminal{)} \terminal{)}\\
\nonterminal{opcode}\is\nonterminal{name}\\
\nonterminal{output}\is\nonterminal{name}\\
\nonterminal{input}\is\nonterminal{register}\\
    \also \nonterminal{constant expression}\\
\nonterminal{register}\is\terminal{(} \terminal{reg}
    \nonterminal{name} \terminal{)}
\end{grammar}

Memory operations read and write memory. The type of the data is provided
explicitly and is checked for writes (reads define the output which is checked
at use.)

\begin{grammar}
\nonterminal{memory access}\is
  \terminal{(} \terminal{load} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{output}
          \nonterminal{address} \terminal{)}\\
 \also
  \terminal{(} \terminal{store} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{address}
          \nonterminal{input} \terminal{)}\\
\nonterminal{address}\is\terminal{(} \nonterminal{input}\oneplus \terminal{)}\\
\end{grammar}

The next is the block. It packages codes together into a single code to
simplify syntax.

\begin{grammar}
\nonterminal{block}\is\terminal{(} \terminal{begin}
  \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

The conditional is also simple. We provide two forms. The constant predicates
are handled in the compile time.
\begin{grammar}
\nonterminal{conditional}\is\terminal{(} \terminal{if-else}
  \nonterminal{predicate} \nonterminal{non-zero branch}
                          \nonterminal{zero branch} \terminal{)}\\
 \also \terminal{(} \terminal{if}
  \nonterminal{predicate} \nonterminal{non-zero branch} \terminal{)}\\
\nonterminal{predicate}\is\nonterminal{input}\\
\nonterminal{non-zero branch}\is\nonterminal{code}\\
\nonterminal{zero branch}\is\nonterminal{code}\\
\end{grammar}

The loop construct always runs through a given number of iterations. The
limits are computed once at the beginning of the loop. The loop variable is
of time int and is visible only inside the loop. Unrolling and prefetching
inside the loop is controlled by the attributes. The loop step is alway $1$.

\begin{grammar}
\nonterminal{loop}\is\terminal{(} \terminal{loop}
  \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{loop variable} \nonterminal{inclusive low}
              \nonterminal{exclusive high} \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{loop variable}\is\nonterminal{output}\\
\nonterminal{inclusive low}\is\nonterminal{input}\\
\nonterminal{exclusive high}\is\nonterminal{input}\\
\end{grammar}

It is possible to use square brackets [[[]]] instead if parentheses [[()]] in
any place as long as the closing backet matches the open one.
Also, [[;]] starts a commnet upto the end of line.

\section{TARGETS}
The following targets are supported:
\begin{itemize}
\item[\terminal{c-header}] The header file for C.
\item[\terminal{c99}] The programming language C as defined in ISO/IEC 9989.
\item[\terminal{c99-64}] The programming language C as defined in ISO/IEC 9989
     on a 64-bit machine.
\item[\terminal{cee}] The programming language C without complex arithmetics.
\item[\terminal{cee-64}] The programming language C without complex arithmetics
     on a 64-bit machine.
\item[\terminal{xlc/bgl}] IBM's XLC compiler for BG/L with intrinsics.
\item[\terminal{bgl}] BG/L assembler.
\end{itemize}

The number of colors is controlled by the shell environment variable \terminal{Nc}, default is 3.

\section{PROCEDURE ATTRIBUTES}
The following procedure attributes are understood:

\begin{grammar}
\terminal{(} \terminal{stem} \nonterminal{a-value}\oneplus\terminal{)}
\end{grammar}

All values of the [[stem]] are concatenated to produce the stem of the procedure
name. The result is affixed and suffixed appropriately to produce the procedure
name.

\begin{grammar}
\terminal{count-flops}
\end{grammar}

If present, the floating point operations in the procedure will be counted and
returned as an [[unsigned int]] result.


\begin{grammar}
\terminal{(} \terminal{return} \nonterminal{name}
    \nonterminal{type} \nonterminal{C type}\terminal{)}
\end{grammar}
Specifies that the procedure returns the final value of register
\nonterminal{name} and has \nonterminal{C type} as the return type. Value of
\nonterminal{type} is used to generate appropriate low level code and should
match \nonterminal{C type}.

\begin{grammar}
\terminal{(}\terminal{return} \nonterminal{output} \nonterminal{type name}
\nonterminal{C type}\terminal{)}
\end{grammar}

The final value of \nonterminal{output} will be returned from the procedure.
The procedure will have \nonterminal{C type} as its return type. The values of
\nonterminal{output} should be of type \nonterminal{type name}.

A procedure can not have both [[count-flops]] and [[return]] attributes.

\section{CONSTANT OPERATIONS}
\begin{grammar}
\terminal{(}\terminal{size-of} $T$\terminal{)}
\end{grammar}
Computes size of  type $T$.

\begin{grammar}
\terminal{(}\terminal{offset-of} $T$ $f$\terminal{)}
\end{grammar}
Computes offset of field $f$ in type $T$.

\begin{grammar}
\terminal{(}\terminal{+} $a$ $b$\any\terminal{)}
\end{grammar}
Computes $a+b\ldots$.
\begin{grammar}
\terminal{(}\terminal{-} $a$ $b$\any\terminal{)}
\end{grammar}
Computes $a-b\ldots$.
\begin{grammar}
\terminal{(}\terminal{*} $a$ $b$\any\terminal{)}
\end{grammar}
Computes $a*b\ldots$.
\begin{grammar}
\terminal{(}\terminal{=} $a$\oneplus\terminal{)}
\end{grammar}
If all arguments are equal, evaluates to $1$, otherwise to $0$.
\begin{grammar}
\terminal{(}\terminal{shift} $a$ $b$\terminal{)}
\end{grammar}
Computes $\left\lfloor2^ba\right\rfloor$.
\begin{grammar}
\terminal{(}\terminal{and} $a$\any\terminal{)}
\end{grammar}
Evaluates to $1$ is all arguments are non-zero, and to $0$ otherwise.
\begin{grammar}
\terminal{(}\terminal{or} $a$\any\terminal{)}
\end{grammar}
Evaluates to $1$ is any argument is non-zero, and to $0$ otherwise.
\begin{grammar}
\terminal{(}\terminal{not} $a$\terminal{)}
\end{grammar}
Evaluates to $1$ is $a=0$ and to $0$ otherwise.

\section{OPERATIONS}
In the following, non-terminal suffices denote implied types:
\begin{center}
\begin{tabular}{cl}
$i$ & integer \\
$f$ & single precision floating point \\
$d$ & double precision floating point \\
$c$ & double precision complex number \\
$p$ & pointer \\
$x$, $y$, $z$, $q$ & unspecifiend types used for reductions \\
$F$ & QCD fermion \\
$l$ & a lower half of QCD fermion \\
$h$ & an upper half of QCD fermion \\
$H$ & QCD projected fermion \\
$S$ & QCD staggered fermion \\
$G$ & QCD gauge field
\end{tabular}
\end{center}

\subsection{QCD operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-fermion} \terminal{()} $r_F$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD fermion from $M[a+b+\cdots]$ in current precision into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-fermion-lo} \terminal{()} $r_l$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load the lower half of QCD fermion from $M[a+b+\cdots]$ in current precision
into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-fermion-hi} \terminal{()} $r_h$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load the upper half of QCD fermion from $M[a+b+\cdots]$ in current precision
into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-projected-fermion} \terminal{()}
 $r_H$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD projected fermion from $M[a+b+\cdots]$ in current precision into
 register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-staggered-fermion} \terminal{()}
 $r_S$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD staggered fermion from $M[a+b+\cdots]$ in current precision into
 register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-su-n} \terminal{()} $r_G$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD gauge matrix from $M[a+b+\cdots]$ in current precision into
 register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-fermion} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_F$ \terminal{)}
\end{grammar}

Store QCD fermion $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-fermion-lo} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_l$
\terminal{)}
\end{grammar}

Store the lower half of QCD fermion in register $r$ into $M[a+b+\cdots]$
in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-fermion-hi} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
 $r_h$
\terminal{)}
\end{grammar}

Store the upper half of QCD fermion in register $r$ into$M[a+b+\cdots]$
in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-projected-fermion} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_H$ \terminal{)}
\end{grammar}

Store QCD projected fermion $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-staggered-fermion} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_S$ \terminal{)}
\end{grammar}

Store QCD staggered fermion $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-su-n} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store QCD gauge matrix $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $u_G$ $a_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u a$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulf-conj} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $u_G$ $a_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger a$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $u_G$ $a_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u a$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-muls} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $u_G$ $a_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u a$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulh-conj} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $u_G$ $a_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger a$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-muls-conj} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $u_G$ $a_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger a$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-mul} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $u_G$  $v_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u v$ for gauge fields.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-mul-conj} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $u_G$  $v_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u v^\dagger$ for gauge fields.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-conj-mul} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $u_G$  $v_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger v$ for gauge fields.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-conj-mul-conj} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $u_G$  $v_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger v^\dagger$ for gauge fields.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-real-trace-conj-mul} \terminal{()}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $b_G$ $c_G$\terminal{)}
\terminal{)}
\end{grammar}
Computes $r\leftarrow \Re \mbox{Tr}(b^\dagger c)$ for gauge fields.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-zerou} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow 0$ for a gauge matrix.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-zerof} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow 0$ for a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-zeroh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow 0$ for a projected fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-zeros} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow 0$ for a staggered fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scaleu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $v_d$ $x_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a gauge matrix.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scalef} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_d$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scalef-hi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_d$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for the upper half of a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scalef-lo} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_d$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for the lower half of a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scaleh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $v_d$ $x_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scales} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $v_d$ $x_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a staggered fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-scaleu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $v_c$ $x_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a gauge matrix.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-scalef} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_c$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-scalef-hi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_c$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for the upper half of a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-scalef-lo} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_c$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for the lower half of a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-scaleh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $v_c$ $x_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-scales} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $v_c$ $x_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-conj-scaleu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $v_c$ $x_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v^\dagger x$ for a gauge matrix.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-conj-scalef} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_c$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v^\dagger x$ for a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-conj-scalef-hi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_c$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v^\dagger x$ for the upper half of a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-conj-scalef-lo} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_c$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v^\dagger x$ for the lower half of a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-conj-scaleh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $v_c$ $x_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v^\dagger x$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-complex-conj-scales} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $v_c$ $x_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v^\dagger x$ for a staggered fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-addu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $a_G$ $b_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a gauge matrix.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-addf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-addh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_H$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-adds} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $a_S$ $b_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-subu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $a_G$ $b_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$ for a gauge matrix.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-subf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-subh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_H$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-subs} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $a_S$ $b_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-maddf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-maddf-lo} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for the lower half of a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-maddf-hi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for the upper halft of the fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-maddh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_H$ $s_d$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-madds} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $a_S$ $s_d$ $b_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-msubf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - s b$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-msubf-lo} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - s b$ for the lower half of a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-msubf-hi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - s b$ for the upper halft of the fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-msubh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_H$ $s_d$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - s b$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-msubs} \terminal{()}
   \terminal{(} $r_S$ \terminal{)}
   \terminal{(} $a_S$ $s_d$ $b_S$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - s b$ for a staggered fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-madd-lohi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $x_d$ $b_l$ $y_d$ $c_h$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + x b + y c$ for a fermion $a$, a lower half $b$ and
an upper half $c$.
% XXXX -- make it so!

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-init} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute fermion norm. The type of $r$ is unspecified here.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-add} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} $a_z$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add a fermion to the norm computation, $r\leftarrow a + b^\dagger b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-lo-add} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} $a_z$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add low part of a fermion to the norm computation,
 $r\leftarrow a + lo(b)^\dagger lo(b)$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-hi-add} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} $a_z$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add high part of a fermion to the norm computation,
 $r\leftarrow a + hi(b)^\dagger hi(b)$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-fini} \terminal{()}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_z$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the final value of the norm from the norm computation.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-snorm-init} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute staggered fermion norm. The type of $r$ is unspecified here.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-snorm-add} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} $a_z$ $b_S$ \terminal{)}
\terminal{)}
\end{grammar}
Add a staggered fermion to the norm computation, $r\leftarrow a + b^\dagger b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-snorm-fini} \terminal{()}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_z$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the final value of the norm from the norm computation.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fdot-init} \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute fermion dot product. The type of $r$ is unspecified here.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fdot-add} \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} $a_q$ $b_F$ $c_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add a fermion to the dot product computation, $r\leftarrow a + b^\dagger c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fdot-fini} \terminal{()}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_q$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the final value from the dot product computation.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-sdot-init} \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute staggered fermion dot product.
The type of $r$ is unspecified here.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-sdot-add} \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} $a_q$ $b_F$ $c_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add a staggered fermion to the dot product computation,
$r\leftarrow a + b^\dagger c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-sdot-fini} \terminal{()}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_q$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the final value from the dot product computation.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fermion-offset} \terminal{()}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $c_i$ $\alpha_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute an offset suitable for loading $\psi^c_\alpha$ with [[load complex]]
for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-projected-fermion-offset} \terminal{()}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $c_i$ $\alpha_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute an offset suitable for loading $\psi^c_\alpha$ with [[load complex]]
for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-offset} \terminal{()}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute an offset suitable for loading $U^a_b$ with [[load complex]]
for a gauge matrix.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-project}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute the projection of a fermion: if $s$ is [[plus]],
compute $r\leftarrow (1+\gamma_d)a$, if $s$ is [[minus]],
compute $r\leftarrow (1-\gamma_d)a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-unproject}
     \terminal{(} \terminal{[} \terminal{unproject} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_H$ \terminal{)}
\terminal{)}
\end{grammar}
Recover a fermion from projection: if $s$ is [[plus]], assume the projection was
$(1+\gamma_d)a$, if $s$ is [[minus]], assume the projection was
$(1-\gamma_d)a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-unproject-add}
     \terminal{(} \terminal{[} \terminal{unproject} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Recover a fermion from projection: if $s$ is [[plus]], assume the projection was
$(1+\gamma_d)b$, if $s$ is [[minus]], assume the projection was
$(1-\gamma_d)b$; add the result to $a$.

\subsection{Complex operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{COMPLEX} \terminal{()} $r_c$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load default precision complex from $M[a+b+\cdots]$ into registero $r$.
 register $r$.

Specific size operations:
\begin{grammar}
\terminal{(} \terminal{load} \terminal{complex-float} \terminal{()} $r_c$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load single precision complex from $M[a+b+\cdots]$ into registero $r$.
 register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{complex-double} \terminal{()} $r_c$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load double precision complex from $M[a+b+\cdots]$ into registero $r$.
 register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{COMPLEX} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_c$ \terminal{)}
\end{grammar}

Store default precision complex $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{complex-float} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_c$ \terminal{)}
\end{grammar}

Store single precision complex $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{complex-double} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_c$ \terminal{)}
\end{grammar}

Store double precision complex $r$ into $M[a+b+\cdots]$.

Double precision complex computations:
\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-sub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-add-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + ib$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-sub-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - ib$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-times-plus-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow ia$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-times-minus-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow -ia$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-rmadd}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $\alpha_d$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + \alpha b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-cmadd}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ $c_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-rmul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $\alpha_d$ $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow \alpha a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-cmul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-cmul-conj}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a^{*} b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-neg}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow -a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-zero}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow 0$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow a$.

%\begin{grammar}
%\terminal{(}\terminal{op} \terminal{complex-}
%     \terminal{(} \terminal{)}
%   \terminal{(} $a_c$ \terminal{)}
%   \terminal{(} $b_c$ $c_c$ \terminal{)}
%\terminal{)}
%\end{grammar}
%Compute $r\leftarrow a ? b$.
%
\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + i b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-real}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow \Re a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-imag}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow \Im a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-norm-init}
     \terminal{()}
   \terminal{(} $r_x$ \terminal{)}
   \terminal{()}
\terminal{)}
\end{grammar}
Prepare to compute complex norm squared.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-norm-add}
     \terminal{()}
   \terminal{(} $r_x$ \terminal{)}
   \terminal{(} $a_x$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Add an element to the complex norm $r\leftarrow a + b^{*}b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-norm-fini}
     \terminal{()}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_x$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the value for the norm $r\leftarrow a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-init}
     \terminal{()}
   \terminal{(} $r_y$ \terminal{)}
   \terminal{()}
\terminal{)}
\end{grammar}
Prepare to compute complex dot product squared.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-add}
   \terminal{()}
   \terminal{(} $r_x$ \terminal{)}
   \terminal{(} $a_x$ $b_c$ $c_c$\terminal{)}
\terminal{)}
\end{grammar}
Add an element to the complex dot product $r\leftarrow a + b^{*}c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-add}
   \terminal{()}
   \terminal{(} $r_x$ \terminal{)}
   \terminal{(} $a_x$ $b_c$ $c_c$\terminal{)}
\terminal{)}
\end{grammar}
Subtract an element from the complex dot product $r\leftarrow a - b^{*}c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-fini}
     \terminal{()}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_x$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the value for the dot product $r\leftarrow a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-real-cmul-conj-init}
     \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} $a_c$ $b_c$\terminal{)}
\terminal{)}
\end{grammar}
Start computing $\sum \Re (x_i^{*} y_i)$:
computes $r\leftarrow \Re (b^{*} c)$ but keeps $r$ in an internal form.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-real-cmul-conj-add}
     \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} $a_q$ $b_c$ $c_c$\terminal{)}
\terminal{)}
\end{grammar}
Continues computing $\sum\Re(x_i^{*}y_i)$, keeps $r$ in the internal form
Computes $r\leftarrow a + \Re (b^{*} c)$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-real-cmul-conj-fini}
     \terminal{()}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_q$ {)}
\terminal{)}
\end{grammar}
Finishes computing $r=\sum\Re(x_i^{*}y_i)$, extracts $r$ from the internal form.

\subsection{Real operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{REAL} \terminal{()} $r_d$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load default precision real from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{float} \terminal{()} $r_d$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load single precision real from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{double} \terminal{()} $r_d$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load double precision real from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{REAL} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store default precision $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{float} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store single precision $r$ into $M[a+b+\cdots]$ in current precision.


\begin{grammar}
\terminal{(} \terminal{store} \terminal{double} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store double precision $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-sub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-mul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-div}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a / b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-madd}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ $c_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b c$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-msub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ $c_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b c$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow a$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-neg}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow - a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-zero}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Set $r\leftarrow 0$.

\subsection{Integer operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{int} \terminal{()} $r_G$
 \terminal{(} $a_i$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load integer from $M[a+b+\cdots]$ in register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{int} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_i$ \terminal{)}
\end{grammar}

Store integer $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-sub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-mul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-div}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \idiv b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-mod}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \imod b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-and}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \iand b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-or}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \ior b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-xor}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \ixor b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-neg}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow - a$.

\subsection{Pointer operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{pointer} \terminal{()} $r_p$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load pointer from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{pointer} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_p$ \terminal{)}
\end{grammar}

Store pointer $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{pointer-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_p$ \terminal{)}
   \terminal{(} $a_p$ $b_i$\terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{pointer-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_p$ \terminal{)}
   \terminal{(} $a_p$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a$.



\end{document}
