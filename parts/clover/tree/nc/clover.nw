\documentclass[twoside,openright,letterpaper]{report}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage[boxed]{algorithm2e}
%\usepackage{epsfig}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{670pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\newcommand{\Cee}{\texttt{C}}

\title{Clover Fermions Implementation $N_c=|:Nc:|$}
\author{Andrew Pochinsky\\Sergey Syritsyn}
\date{Version |:Version:|}

\begin{document}
\maketitle
\thispagestyle{empty}\hbox{}
\vfill
\copyright 2009--2014 Massachusetts Institute of Technology

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\pagebreak

\tableofcontents
\pagebreak

\chapter{PHYSICS}

The Domain Wall Fermion Dirac operator is defined by
\begin{equation}
\left\langle\bar\psi|D_{CL}|\psi\right\rangle =
  \sum_{x,x'}\bar\psi(x)D_{CL}(x,x')\psi(x'),
\end{equation}
where
\begin{eqnarray}
D_{CL}(x,x')  &= & \delta_{x,x'} - \kappa D_W(x,x') - \kappa c_{SW} T_{SW}(x,x')
\label{D_CL}\\
D_W(x,x') &=& \sum_{\mu=0}^3\left[(1-\gamma_\mu) U_\mu(x)\delta_{x,x'-\hat\mu}
         +(1+\gamma_\mu) U_\mu^\dagger(x-\hat\mu)\delta_{x,x'+\hat\mu}\right]
\\
T_{SW}(x,x') &=& \delta_{x,x'} \sum_{\mu=0}^2\sum_{\nu=\mu+1}^3 \sigma_{\mu\nu}F_{\mu\nu}(x)
\label{Tsw}\\
F_{\mu\nu}(x) &=&\frac{1}{8i}\left(G_{\mu\nu}(x)-G_{\mu\nu}^\dagger(x)\right)
\label{action-F}\\
G_{\mu\nu}(x) &=& U_\mu(x)U_\nu(x+\hat\mu)
                       U_\mu^\dagger(x+\hat\nu)U_\nu^\dagger(x)\nonumber\\
            && + U_\nu^\dagger(x-\hat\nu)U_\mu(x-\hat\nu)
                       U_\nu(x-\hat\nu+\hat\mu)U_\mu^\dagger(x)\nonumber\\
            && + U_\mu^\dagger(x-\hat\mu)U_\nu^\dagger(x-\hat\nu-\hat\mu)
                       U_\mu(x-\hat\nu-\hat\mu)U_\nu(x-\hat\nu)\nonumber\\
            && + U_\nu(x)U_\mu^\dagger(x+\hat\nu-\hat\mu)
                       U_\nu^\dagger(x-\hat\mu)U_\nu(x-\hat\mu)
\label{action-G}
\end{eqnarray}

The interface to the library is more generic than equations above would
suggest, see detailed description of gauge field import routines in
section~\ref{import-gauge} below.

\pagebreak
\section{Gamma Matrices}
We use the same $\gamma$-matrix basis as Chroma to simplify conversion between
two codes. The Clover code expects $\gamma_5$ and $\sigma_{\mu\nu}$ to have values
specified below.

\begin{eqnarray}
\gamma_5 &=& \gamma_0 \gamma_1 \gamma_2 \gamma_3 = \sigma_3 \otimes 1 =
           \left(\begin{array}{cc}
             1 & 0 \\
             0 & -1
           \end{array}\right) =
           \left(\begin{array}{cccc}
             1 & 0 & 0 & 0\\
             0 & 1 & 0 & 0\\
             0 & 0 &-1 & 0\\
             0 & 0 & 0 &-1
           \end{array}\right),\nonumber\\
\sigma_{\mu\nu} &=& \frac{i}{2}\left[\gamma_\mu,\gamma_\nu\right],\nonumber\\
\sigma_{01} &=& 1 \otimes \sigma_3 
   = \left(\begin{array}{cc}\sigma_3&0\\0&\sigma_3\end{array}\right)
   = \left(\begin{array}{cccc}
        1 & 0 & 0 & 0 \\
        0 & -1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        0 & 0 & 0 & -1
     \end{array}\right),\nonumber\\
  \sigma_{02} &=& 1 \otimes \sigma_2
   = \left(\begin{array}{cc}\sigma_2&0\\0&\sigma_2\end{array}\right)
   = \left(\begin{array}{cccc}
        0 & -i & 0 & 0 \\
        i & 0 & 0 & 0 \\
        0 & 0 & 0 & -i \\
        0 & 0 & i & 0
     \end{array}\right),\nonumber\\
  \sigma_{03} &=& -\sigma_3 \otimes \sigma_1
   = \left(\begin{array}{cc}-\sigma_1&0\\0&\sigma_1\end{array}\right)
   = \left(\begin{array}{cccc}
        0 & -1 & 0 & 0 \\
        -1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0
     \end{array}\right),\nonumber\\
  \sigma_{12} &=& 1 \otimes \sigma_1
   = \left(\begin{array}{cc}\sigma_1&0\\0&\sigma_1\end{array}\right)
   = \left(\begin{array}{cccc}
        0 & 1 & 0 & 0 \\
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0
     \end{array}\right),\nonumber\\
  \sigma_{13} &=& \sigma_3 \otimes \sigma_2
   = \left(\begin{array}{cc}\sigma_2&0\\0&-\sigma_2\end{array}\right)
   = \left(\begin{array}{cccc}
        0 & -i & 0 & 0 \\
        i & 0 & 0 & 0 \\
        0 & 0 & 0 & i \\
        0 & 0 & -i & 0
     \end{array}\right),\nonumber\\
  \sigma_{23} &=& -\sigma_3 \otimes \sigma_3
   = \left(\begin{array}{cc}-\sigma_3&0\\0&\sigma_3\end{array}\right)
   = \left(\begin{array}{cccc}
        -1 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        0 & 0 & 0 & -1
     \end{array}\right).\nonumber
\end{eqnarray}

Fragments for $\gamma_\mu$ below are not the most fool-proof, but they should do
for now.

\pagebreak
\begin{equation}
\gamma_0 = -\sigma_2 \otimes \sigma_1  =
           \left(\begin{array}{cc}
                0&i\sigma_1\\
                -i\sigma_1&0
             \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&0&i\\
                                 0&0&i&0\\
                                 0&-i&0&0\\
                                 -i&0&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_0)$>>=
((project 0 plus) . ((plus-one 0 plus-i 3)
                     (plus-one 1 plus-i 2)))
@
<<Unproject $(1+\gamma_0)$>>=
((unproject 0 plus) . ((plus-one 0)
                       (plus-one 1)
                       (minus-i 1)
                       (minus-i 0)))
@
<<Project $(1-\gamma_0)$>>=
((project 0 minus) . ((plus-one 0 minus-i 3)
                      (plus-one 1 minus-i 2)))
@
<<Unproject $(1-\gamma_0)$>>=
((unproject 0 minus) . ((plus-one 0)
                        (plus-one 1)
                        (plus-i 1)
                        (plus-i 0)))
@

%\pagebreak
\begin{equation}
\gamma_1 = \sigma_2 \otimes \sigma_2  = 
           \left(\begin{array}{cc}
                  0 & -i\sigma_2\\
                  i\sigma_2 & 0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&0&-1\\
                                 0&0&1&0\\
                                 0&1&0&0\\
                                 -1&0&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_1)$>>=
((project 1 plus) . ((plus-one 0 minus-one 3)
                     (plus-one 1 plus-one 2)))
@
<<Unproject $(1+\gamma_1)$>>=
((unproject 1 plus) . ((plus-one 0)
                       (plus-one 1)
                       (plus-one 1)
                       (minus-one 0)))
@
<<Project $(1-\gamma_1)$>>=
((project 1 minus) . ((plus-one 0 plus-one 3)
                      (plus-one 1 minus-one 2)))
@
<<Unproject $(1-\gamma_1)$>>=
((unproject 1 minus) . ((plus-one 0)
                        (plus-one 1)
                        (minus-one 1)
                        (plus-one 0)))
@

\pagebreak
\begin{equation}
\gamma_2 = -\sigma_2 \otimes \sigma_3  = 
           \left(\begin{array}{cc}
                   0 & i\sigma_3\\
                 -i\sigma_3&0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&i&0\\
                                 0&0&0&-i\\
                                 -i&0&0&0\\
                                 0&i&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_2)$>>=
((project 2 plus) . ((plus-one 0 plus-i 2)
                     (plus-one 1 minus-i 3)))
@
<<Unproject $(1+\gamma_2)$>>=
((unproject 2 plus) . ((plus-one 0)
                       (plus-one 1)
                       (minus-i 0)
                       (plus-i 1)))
@
<<Project $(1-\gamma_2)$>>=
((project 2 minus) . ((plus-one 0 minus-i 2)
                      (plus-one 1 plus-i 3)))
@
<<Unproject $(1-\gamma_2)$>>=
((unproject 2 minus) . ((plus-one 0)
                        (plus-one 1)
                        (plus-i 0)
                        (minus-i 1)))
@

%\pagebreak
\begin{equation}
\gamma_3 = \sigma_1 \otimes 1 =
           \left(\begin{array}{cc}
                  0 & 1\\
                  1 & 0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&1&0\\
                                 0&0&0&1\\
                                 1&0&0&0\\
                                 0&1&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_3)$>>=
((project 3 plus) . ((plus-one 0 plus-one 2)
                     (plus-one 1 plus-one 3)))
@
<<Unproject $(1+\gamma_3)$>>=
((unproject 3 plus) . ((plus-one 0)
                       (plus-one 1)
                       (plus-one 0)
                       (plus-one 1)))
@
This is our starting point in sums over directions. For historical reasons the
name starts with [[mdwf]]. This is what other parts of QA0 expect.
<<Start $\mu$ sum>>=
(define mdwf-start-sum-dimension 3)
(define mdwf-start-sum-direction 'plus)
@

<<Project $(1-\gamma_3)$>>=
((project 3 minus) . ((plus-one 0 minus-one 2)
                      (plus-one 1 minus-one 3)))
@
<<Unproject $(1-\gamma_3)$>>=
((unproject 3 minus) . ((plus-one 0)
                        (plus-one 1)
                        (minus-one 0)
                        (minus-one 1)))
@

Now let us collect the $\gamma$-matrix projections and reconstructions. We
put them all together into [[mdwf-basis]] as an a list of pairs with keys
of the form [[(<op> <dir> <sign>)]].
<<Scheme definitions>>=
(define mdwf-basis '(
  <<Project $(1+\gamma_0)$>>
  <<Project $(1+\gamma_1)$>>
  <<Project $(1+\gamma_2)$>>
  <<Project $(1+\gamma_3)$>>
  <<Project $(1-\gamma_0)$>>
  <<Project $(1-\gamma_1)$>>
  <<Project $(1-\gamma_2)$>>
  <<Project $(1-\gamma_3)$>>
  <<Unproject $(1+\gamma_0)$>>
  <<Unproject $(1+\gamma_1)$>>
  <<Unproject $(1+\gamma_2)$>>
  <<Unproject $(1+\gamma_3)$>>
  <<Unproject $(1-\gamma_0)$>>
  <<Unproject $(1-\gamma_1)$>>
  <<Unproject $(1-\gamma_2)$>>
  <<Unproject $(1-\gamma_3)$>>))
@

We also define a starting link in a sum over links:
<<Scheme definitions>>=
<<Start $\mu$ sum>>
@

Here is a module for PLT:
<<File [[../utils/basis.ss]]>>=
(module basis
        mzscheme
   (provide mdwf-basis
            mdwf-start-sum-dimension
            mdwf-start-sum-direction)
   <<Scheme definitions>>
)
@

\pagebreak\section{Preconditioning}\label{precond}
We use four dimensional preconditioner to improve convergence of the CG.
Let us color the lattice sites according to the
parity of $x_0+x_1+x_2+x_3$. Then we can rewrite $D_{CL}$ from Eq.~(\ref{D_CL})
as follows:
\begin{equation}\label{EO-form}
D_{CL}=\left(\begin{array}{cc}
A_{oo} & B_{oe}\\
B_{eo} & A_{ee}
\end{array}\right),
\end{equation}
where
\begin{eqnarray}
A_{oo}(x,x') & = & \delta_{x,x'} - \kappa c_{SW} T(x,x'), \\
B_{oe}(x,x') & = & -\kappa
            \sum_{\mu=0}^{3}\left[(1-\gamma_\mu)U_\mu(x)\delta_{x,x'-\hat\mu}
         +(1+\gamma_\mu)U_\mu^{\dagger}(x-\hat\mu)\delta_{x,x'+\hat\mu}\right],
\end{eqnarray}
and similary for other parity components.
(Hereafter spinor and color indices are suppressed but presumed.)

Let us rewrite Eq.~(\ref{EO-form}) as follows:
\begin{equation}
D_{CL}=
\left(\begin{array}{cc}
I_{oo} & 0\\
B_{eo}A_{oo}^{-1} & I_{ee}
\end{array}\right)
\left(\begin{array}{cc}
A_{oo} & B_{oe}\\
0 & A_{ee}-B_{eo}A_{oo}^{-1}B_{oe}
\end{array}\right).
\end{equation}

To solve the equation
\[
D_{CL}\psi=
\left(\begin{array}{cc}
A_{oo} & B_{oe}\\
B_{eo} & A_{ee}
\end{array}\right)
\left(\begin{array}{c}\psi_e\\\psi_o\end{array}\right) =
   \left(\begin{array}{c}\eta_e\\\eta_o\end{array}\right),
\]
one performs the following steps:
\begin{enumerate}
\item Use $M=A_{ee}-B_{eo}A_{oo}^{-1}B_{oe}$ in the
following.
\item Use $M^\dagger=A_{ee}^\dagger-\left(B_{oe}\right)^\dagger
\left(A_{oo}^{-1}\right)^\dagger
\left(B_{eo}\right)^\dagger$ in the following.
\item Compute
\[
\chi_e =M^{\dagger} \left(\eta_e
            - B_{eo}A_{oo}^{-1}\eta_o\right).
\]
\item Solve
\begin{equation}
M^{\dagger}M\psi_e = \chi_e
\label{normal-eq}
\end{equation}
for $\psi_e$ using Alg.~\ref{real}.
\item Compute
\begin{eqnarray}
\psi_o &=& A_{oo}^{-1}\left(\eta_o-B_{oe}\psi_e\right).
\end{eqnarray}
\end{enumerate}

Note, that computing the inverse of $A_{oo}$ is local.
One can write Eq.~({\ref{Tsw}}) as follows
\begin{eqnarray*}
A_{oo} &=& \left(\begin{array}{cc}X & 0 \\ 0 & Y\end{array}\right),\\
X &=& \left(\begin{array}{cc}
1-\kappa c_{SW}(F_{01}-F_{23}) &
-\kappa c_{SW}\left((F_{12}-F_{03})-i(F_{02}+F_{13})\right) \\
-\kappa c_{SW}\left((F_{12}-F_{03})+i(F_{02}+F_{13})\right)&
1+\kappa c_{SW}(F_{01}-F_{23})
\end{array}\right),\\
Y &=& \left(\begin{array}{cc}
1-\kappa c_{SW}(F_{01}+F_{23}) &
-\kappa c_{SW}\left((F_{12}+F_{03})-i(F_{02}-F_{13})\right)\\
-\kappa c_{SW}\left((F_{12}+F_{03})+i(F_{02}-F_{13})\right)&
1+\kappa c_{SW}(F_{01}+F_{23})
\end{array}\right).
\end{eqnarray*}
Here $X$ acts on two upper components of the fermion and $Y$ acts on
two lower components.

\chapter{ALGORITHMS}

\section{Conjugate gradient}
The equation
\[
   M^\dagger M \psi = \chi
\]
can be solve by the conjugate gradient method if the condition number of
 $M^\dagger M$ is small enough.
\IncMargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$M$, the matrix}
\KwIn{$\chi$, the right hand side of the linear equation}
\KwIn{$\psi_0$, an initial guess}
\KwIn{$n$, the maximum number of iterations}
\KwIn{$\epsilon$, required precision}
\KwOut{$\psi$, approximate solution}
\KwOut{$r$, final residue}
\KwOut{$k$, number of iterations used}
\SetKw{Break}{break}
\DontPrintSemicolon
\Begin{
  $\psi\leftarrow \psi_0$\;
  $\rho\leftarrow \chi - M^{\dagger}M\psi$\;
  $\pi\leftarrow \rho$\;
  $r\leftarrow\langle \rho,\rho\rangle$\;
  $k\leftarrow 0$\;
  \While{$r > \epsilon$ or $k < n$}{
    $\omega\leftarrow M\pi$\;
    $\zeta\leftarrow M^{\dagger}\omega$\;
    $a\leftarrow r/\langle \omega,\omega\rangle$\;
    $\rho\leftarrow \rho - a \zeta$\;
    $ g \leftarrow \langle \rho,\rho\rangle$\;
    \If{$ g<\epsilon$}{
       $\psi\leftarrow \psi + a \pi$\;
       $r \leftarrow g$\;
       \Break}
    $b\leftarrow g/r$\;
    $r\leftarrow g$\;
    $\psi\leftarrow \psi + a \pi$\;
    $\pi\leftarrow \rho + b \pi$\;
    $k\leftarrow k + 1$\;
  }
  \Return {$\psi$, $r$, $k$}.
}
\caption{\label{real}Conjugate Gradient Solver.}
\end{algorithm}
\DecMargin{20pt}


\chapter{INTERFACE}
The Clover interface is fully functional to isolate users of the code from
implementation details. Several types defined in the interface provide help
with typechecking.
<<File [[../port/qop-clover.h]]>>=
#ifndef QOP_|:Nc:|_CLOVER_1a978487255540d18dde15681e99166a
# define `QOP_|:Nc:|_CLOVER_1a978487255540d18dde15681e99166a
  <<Interface macros>>
  <<Interface types>>
  <<Interface functions>>
# if defined(QOP_CLOVER_DEFAULT_PRECISION) && (QOP_CLOVER_DEFAULT_PRECISION == 'F')
   <<Single precision defaults>>
# endif
# if defined(QOP_CLOVER_DEFAULT_PRECISION) && (QOP_CLOVER_DEFAULT_PRECISION == 'D')
    <<Double precision defaults>>
# endif
#endif /* !defined(QOP_|:Nc:|_CLOVER_1a978487255540d18dde15681e99166a) */
@


\section{Magic numbers}
The numbers below are provided as names for magic numbers in the code. They can
not be safely changed.

First, the dimension is always four:
<<Interface macros>>=
#define `QOP_|:Nc:|_CLOVER_DIM 4
@

Next, the number of components in the Dirac fermion and the projected fermion
<<Interface macros>>=
#define `QOP_|:Nc:|_CLOVER_FERMION_DIM 4
#define `QOP_|:Nc:|_CLOVER_PROJECTED_FERMION_DIM 2
@

We work only with $SU(|:Nc:|)$
<<Interface macros>>=
#define `QOP_|:Nc:|_CLOVER_COLORS |:Nc:|
@

\section{Library version}
The following function returns a version of the library. The goal is to
provide enough information to uniquely identify library's version. Since
there are many features packed into the library, a human-readable string is
returned.
<<Interface functions>>=
const char *`QOP_|:Nc:|_CLOVER_version(void);
@

\section{Library signature}
The following function returns a constant string which specifies the
format of the deflator state. If the format of exported state deflator
changes, a different string will be returned.

<<Interface functions>>=
const char *`QOP_|:Nc:|_CLOVER_signature(struct QOP_|:Nc:|_CLOVER_State *state);
@

\section{Parity of even-odd preconditioning}
The parity of even-odd preconditioning used internally. The the returned value is zero,
[[QDP_even_L()]] is used internally, otherwise the internals work on [[QDP_odd_L()]].
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_parity(struct QOP_|:Nc:|_CLOVER_State *state);
@

\section{Performance monitoring}
Each interface function records its exectution time and number of floating point
operations in the [[State]] structure. These numbers are accessed via the
following function. Only data on the current node is recorded. The function
returns [[0]] if performance counters are updated.
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_performance(double *time_sec,
                              long long *flops,
                              long long *sent,
                              long long *receive,
                              struct QOP_|:Nc:|_CLOVER_State *state);
@

\section{Initialization}
All library state is incapsulated into an opaque structure. We do not need
to expose any components of the structure to the user.
<<Interface types>>=
struct `QOP_|:Nc:|_CLOVER_State;
@

Initialization needs to know lattice configuration and its layout on the machine.
It expects to find the information in the following structure
<<Interface types>>=
struct `QOP_|:Nc:|_CLOVER_Config {
  int    self;                      /* this node QMP id */
  int    master_p;                  /* if != 0, do I/O from this node */
  int    rank;                      /* lattice rank, must be 4 */
  int   *lat;                       /* [rank] */
  int   *net;                       /* [rank] */
  int   *neighbor_up;               /* [rank], QMP ids of neighbors in up dirs */
  int   *neighbor_down;             /* [rank], QMP ids of neighbors in down dirs */
  void (*sublattice)(int lo[],      /*   [rank] */
                     int hi[],      /*   [rank] */
                     int node,      /*   any node QMP id */
                     void *env);    /*   lexical variables */
  void  *env;                       /* lexical variables for sublattice */
};
@
This structure is used by [[QOP_|:Nc:|_CLOVER_init()]] only. Once the initialization is done,
the elements of the structure (and data they point to) will never be referenced again.

The library initialization routine creates the state structure and fills it
with necessary information. It returns [[0]] if successful and a non-zero value
otherwise. In any case [[state_ptr]] is set to some value suitable for other
library functions.
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_init(struct QOP_|:Nc:|_CLOVER_State **state_ptr,
                      struct QOP_|:Nc:|_CLOVER_Config *config);
@
Arguments of [[init()]] are
\begin{itemize}
\item[\texttt{state\_ptr}] points to the [[State]] to be set.
\item[\texttt{config}] 4--d lattice layout information
\end{itemize}

When [[QOP_|:Nc:|_CLOVER_init()]] returns, [[*state_ptr]] will point to a valid
state of the library (if any error occurs during initialization, the
error will be stored in [[*stat_ptr]].

It is possible to call [[QOP_|:Nc:|_CLOVER_init()]] multiple times with different
arguments. The library does not require that the lattice size and layout agree
in different calls.

\section{Cleanup}
When the state is no longer needed it should be closed by the following function
<<Interface functions>>=
void `QOP_|:Nc:|_CLOVER_fini(struct QOP_|:Nc:|_CLOVER_State **state_ptr);
@
It is an error to use [[*state_ptr]] after it was closed. To help in error
detection this function sets [[*state_ptr]] to [[NULL]]. All library functions
check if the state they are passed is [[NULL]] and abort if it is.

\section{Errors}
When something goes wrong in the library, a library function will return some
non-zero value and store the error code in the library state. The error codes
are accessible as human-readable strings via the following function:
<<Interface functions>>=
const char *`QOP_|:Nc:|_CLOVER_error(struct QOP_|:Nc:|_CLOVER_State *state);
@
Note that the first error will be latched until [[QOP_|:Nc:|_CLOVER_error()]] is
called.
This is a design choice made to help in pinpointing the origin of the problem
when something goes wrong intead of reporting spiritious errors if multiple
calls to the library are made before an error is checked for. If there is no
error, [[QOP_|:Nc:|_CLOVER_error()]] returns [[NULL]]. The function could be called
multiple times, it does not reset the error code, instead it marks in the state
that the error was reported thus allowing latching another error.

\section{Gauge}\label{import-gauge}
Any gauge field should be imported into the library format before it could
be used. To keep the interface as general as possible, we use a query function
approach for inport. There are two versions of [[QOP_|:Nc:|_CLOVER_import_gauge]], one
for double precision, another for single precision. Note that the clover
action parameters are specified in the gauge import routines. 
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_import_gauge(struct QOP_F|:Nc:|_CLOVER_Gauge **gauge_ptr,
                                struct QOP_|:Nc:|_CLOVER_State *state,
                                double kappa,
                                double c_sw,
                                double (*U_reader)(int dir,
                                                   const int pos[4],
                                                   int a,
                                                   int b,
                                                   int re_im,
                                                   void *env),
                                double (*F_reader)(int mu,
                                                   int nu,
                                                   const int pos[4],
                                                   int a,
                                                   int b,
                                                   int re_im,
                                                   void *env),
                                void *env);
int `QOP_D|:Nc:|_CLOVER_import_gauge(struct QOP_D|:Nc:|_CLOVER_Gauge **gauge_ptr,
                                struct QOP_|:Nc:|_CLOVER_State *state,
                                double kappa,
                                double c_sw,
                                double (*U_reader)(int dir,
                                                   const int pos[4],
                                                   int a,
                                                   int b,
                                                   int re_im,
                                                   void *env),
                                double (*F_reader)(int mu,
                                                   int nu,
                                                   const int pos[4],
                                                   int a,
                                                   int b,
                                                   int re_im,
                                                   void *env),
                                void *env);
@
The [[U_reader()]] points to a function that provides a value of the gauge field
at a given point on the lattice, e.g., it returns the value of
[[U[dir][pos][a][b].re]] for [[re_im==0]] and 
[[U[dir][pos][a][b].im]] for [[re_im==1]]. If will be called only for [[pos]] in
a local sublattice.
The [[F_reader()]] points to a function that provides a value of the clover
plaquette, e.g., it returns the value of
[[F[mu][nu][pos][a][b].re]] for [[re_im==0]] and
[[F[mu][nu][pos][a][b].im]] for [[re_im==1]]. If will be called only for [[pos]]
in a local sublattice.
The [[U_reader()]] and [[F_reader()] functions are
passed the [[env]] parameter
that may be used to access the guage field from the outer space.  The [[env]]
parameter is not used by [[import_gauge()]] functions for any other purpose.

Note that [[import_gauge]] routines do not assume that [[F_reader()]] provides
values as specified by Eqs.~(\ref{action-F}) and~(\ref{action-G}). In
particular, values returned by [[F_reader()]] are not expected to be related to
values returned by [[U_reader()]] at all.

If the function succeeds then the [[*gauge_ptr]] will be initialized to a value
that may be passed to other library functions. If something goes wrong,
[[*gauge_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F|:Nc:|_CLOVER_Gauge;
struct `QOP_D|:Nc:|_CLOVER_Gauge;
@

It is convenient to have a converter from double to single precision. It allocates space
for single precision result.
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_gauge_float_from_double(struct QOP_F|:Nc:|_CLOVER_Gauge **result,
                                              struct QOP_D|:Nc:|_CLOVER_Gauge *gauge_ptr);
@

We also need a couple of destructors for gauge fields. For convenience, they
will accept [[NULL]] intead of a valid gauge field.
<<Interface functions>>=
void `QOP_F|:Nc:|_CLOVER_free_gauge(struct QOP_F|:Nc:|_CLOVER_Gauge **gauge_ptr);
void `QOP_D|:Nc:|_CLOVER_free_gauge(struct QOP_D|:Nc:|_CLOVER_Gauge **gauge_ptr);
@

Here are macros defining default values for gauge field types and functions:
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_import_gauge QOP_|:Nc:|_CLOVER_import_gauge
#define `QOP_|:Nc:|_CLOVER_free_gauge QOP_F|:Nc:|_CLOVER_free_gauge
#define `QOP_|:Nc:|_CLOVER_Gauge QOP_F|:Nc:|_CLOVER_Gauge
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_import_gauge QOP_D|:Nc:|_CLOVER_import_gauge
#define `QOP_|:Nc:|_CLOVER_free_gauge QOP_D|:Nc:|_CLOVER_free_gauge
#define `QOP_|:Nc:|_CLOVER_Gauge QOP_D|:Nc:|_CLOVER_Gauge
@

The following functions can be used to export $A_{oo}^{-1}$:
<<Interface functions>>=
int QOP_F|:Nc:|_CLOVER_export_inv_clover(void (*writer)(const int pos[4],
                                                   int a, int i, int b, int j,
                                                   int re_im,
                                                   double value,
                                                   void *env),
                                    void *env,
                                    const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge);
int QOP_D|:Nc:|_CLOVER_export_inv_clover(void (*writer)(const int pos[4],
                                                   int a, int i, int b, int j,
                                                   int re_im,
                                                   double value,
                                                   void *env),
                                    void *env,
                                    const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge);
@
The [[writer()]] function will be called for all odd sites on the local
sublattice, for all color components [[a]], [[b]], and for the upper and
lower half-blocks in [[i]], [[j]].

\section{Fermions}
Unlike the gauge field, fermions are provided with a richer set of functions.
In addition to import and destruction, they could be created empty and exported.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_import_fermion(struct QOP_F|:Nc:|_CLOVER_Fermion **fermion_ptr,
                                  struct QOP_|:Nc:|_CLOVER_State *state,
                                  double (*reader)(const int pos[4],
                                                   int color,
                                                   int dirac,
                                                   int re_im,
                                                   void *env),
                                  void *env);
int `QOP_D|:Nc:|_CLOVER_import_fermion(struct QOP_D|:Nc:|_CLOVER_Fermion **fermion_ptr,
                                  struct QOP_|:Nc:|_CLOVER_State *state,
                                  double (*reader)(const int pos[4],
                                                   int color,
                                                   int dirac,
                                                   int re_im,
                                                   void *env),
                                  void *env);
@
The [[reader()]] points to a function that provides a value of the fermion field
at a given point on the lattice, e.g., it returns the value of
[[F[pos][color][dirac].re]] for [[re_im==0]] and 
[[F[pos][color][dirac].im]] for [[re_im==1]].
If will be called only for [[pos]] in
a local sublattice. The [[env]] parameter
is passed blindly to the [[reader()]] without any interpretation whatsoever. It
could be used to access the fermion field from the outer space or for any other
purpose.

If the function succeeds then the [[*fermion_ptr]] will be initialized to a
value that may be passed to other library functions. If something goes wrong,
[[*fermion_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F|:Nc:|_CLOVER_Fermion;
struct `QOP_D|:Nc:|_CLOVER_Fermion;
@

One may also need to create a fermion field without any useful initial value.
For convenience, we provide functions to do that
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_allocate_fermion(struct QOP_F|:Nc:|_CLOVER_Fermion **fermion_ptr,
                                 struct QOP_|:Nc:|_CLOVER_State *state);
int `QOP_D|:Nc:|_CLOVER_allocate_fermion(struct QOP_D|:Nc:|_CLOVER_Fermion **fermion_ptr,
                                 struct QOP_|:Nc:|_CLOVER_State *state);
@

Unlike the gauge fields, fermions need a way to be exported back to the user.
We also use a functional interface to provide indexing.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_export_fermion(void (*writer)(const int pos[4],
                                                 int color,
                                                 int dirac,
                                                 int re_im,
                                                 double value,
                                                 void *env),
                                  void *env,
                                  const struct QOP_F|:Nc:|_CLOVER_Fermion *fermion);
int `QOP_D|:Nc:|_CLOVER_export_fermion(void (*writer)(const int pos[4],
                                                 int color,
                                                 int dirac,
                                                 int re_im,
                                                 double value,
                                                 void *env),
                                  void *env,
                                  const struct QOP_D|:Nc:|_CLOVER_Fermion *fermion);
@

A fast path interface to BLAS allows one to convert between a half-fermion
and an array of float (actually complex) numbers that BLAS and friends prefer.
The [[size]] parameters must be at least as large as the value returned by [[QDP_|:Nc:|_CLOVER_half_fermion_size()]] below.
Export function write exactly [[QDP_|:Nc:|_CLOVER_half_fermion_size()]] numbers to [[data]];
import functions read exactly [[QDP_|:Nc:|_CLOVER_half_fermion_size()]] numbers from [[data]].
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_blas_from_half_fermion(float *data,
                                              int size,
                                              const struct QOP_F|:Nc:|_CLOVER_HalfFermion *hfermion);
int `QOP_D|:Nc:|_CLOVER_blas_from_half_fermion(double *data,
                                              int size,
                                              const struct QOP_D|:Nc:|_CLOVER_HalfFermion *hfermion);
int `QOP_F|:Nc:|_CLOVER_half_fermion_from_blas(struct QOP_F|:Nc:|_CLOVER_HalfFermion *hfermion,
                                              const float *data,
                                              int size);
int `QOP_D|:Nc:|_CLOVER_half_fermion_from_blas(struct QOP_D|:Nc:|_CLOVER_HalfFermion *hfermion,
                                              const double *data,
                                              int size);
@
We also provide a way to determine the number of floating point numbers needed to represent a half-fermion.
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_half_fermion_size(struct QOP_|:Nc:|_CLOVER_State *state_ptr);
@

We also need a couple of destructors for fermion fields. For convenience, they
will accept [[NULL]] intead of a valid fermion field.
<<Interface functions>>=
void `QOP_F|:Nc:|_CLOVER_free_fermion(struct QOP_F|:Nc:|_CLOVER_Fermion **fermion_ptr);
void `QOP_D|:Nc:|_CLOVER_free_fermion(struct QOP_D|:Nc:|_CLOVER_Fermion **fermion_ptr);
@

Finally, macros for prefered precision
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_import_fermion QOP_F|:Nc:|_CLOVER_import_fermion
#define `QOP_|:Nc:|_CLOVER_export_fermion QOP_F|:Nc:|_CLOVER_export_fermion
#define `QOP_|:Nc:|_CLOVER_allocate_fermion QOP_F|:Nc:|_CLOVER_allocate_fermion
#define `QOP_|:Nc:|_CLOVER_blas_from_half_fermion QOP_F|:Nc:|_CLOVER_blas_from_half_fermion
#define `QOP_|:Nc:|_CLOVER_half_fermion_from_blas QOP_F|:Nc:|_CLOVER_half_fermion_from_blas
#define `QOP_|:Nc:|_CLOVER_free_fermion QOP_F|:Nc:|_CLOVER_free_fermion
#define `QOP_|:Nc:|_CLOVER_Fermion QOP_F|:Nc:|_CLOVER_Fermion
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_import_fermion QOP_D|:Nc:|_CLOVER_import_fermion
#define `QOP_|:Nc:|_CLOVER_export_fermion QOP_D|:Nc:|_CLOVER_export_fermion
#define `QOP_|:Nc:|_CLOVER_allocate_fermion QOP_D|:Nc:|_CLOVER_allocate_fermion
#define `QOP_|:Nc:|_CLOVER_blas_from_half_fermion QOP_D|:Nc:|_CLOVER_blas_from_half_fermion
#define `QOP_|:Nc:|_CLOVER_half_fermion_from_blas QOP_D|:Nc:|_CLOVER_half_fermion_from_blas
#define `QOP_|:Nc:|_CLOVER_free_fermion QOP_D|:Nc:|_CLOVER_free_fermion
#define `QOP_|:Nc:|_CLOVER_Fermion QOP_D|:Nc:|_CLOVER_Fermion
@

\section{Preconditioned fermions}
We also need preconditioned fermions. They exist in parallel with full fermions
but the exact relation is not specified.
Unlike the gauge field, fermions are provided with a richer set of functions.
In addition to import and destruction, they could be created empty and exported.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_import_half_fermion(struct QOP_F|:Nc:|_CLOVER_HalfFermion **hfermion_ptr,
                                       struct QOP_|:Nc:|_CLOVER_State *state,
                                       double (*reader)(const int pos[4],
                                                        int color,
                                                        int dirac,
                                                        int re_im,
                                                        void *env),
                                       void *env);
int `QOP_D|:Nc:|_CLOVER_import_half_fermion(struct QOP_D|:Nc:|_CLOVER_HalfFermion **hfermion_ptr,
                                       struct QOP_|:Nc:|_CLOVER_State *state,
                                       double (*reader)(const int pos[4],
                                                        int color,
                                                        int dirac,
                                                        int re_im,
                                                        void *env),
                                       void *env);
@
The [[reader()]] points to a function that provides a value of the
preconditioned fermion field
at a given point on the lattice, e.g., it returns the value of
[[F[pos][color][dirac].re]] for [[re_im==0]] and 
[[F[pos][color][dirac].im]] for [[re_im==1]].
If will be called only for [[pos]] in
a local sublattice. The [[env]] parameter
is passed blindly to the [[reader()]] without any interpretation whatsoever. It
could be used to access the half fermion in the calling layer.

If the function succeeds then the [[*hfermion_ptr]] will be initialized to a
value that may be passed to other library functions. If something goes wrong,
[[*hfermion_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F|:Nc:|_CLOVER_HalfFermion;
struct `QOP_D|:Nc:|_CLOVER_HalfFermion;
@

One may also need to create a fermion field without any useful initial value.
For convenience, we provide functions to do that
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_allocate_half_fermion(struct QOP_F|:Nc:|_CLOVER_HalfFermion **hfermion_ptr,
                                         struct QOP_|:Nc:|_CLOVER_State *state);
int `QOP_D|:Nc:|_CLOVER_allocate_half_fermion(struct QOP_D|:Nc:|_CLOVER_HalfFermion **hfermion_ptr,
                                         struct QOP_|:Nc:|_CLOVER_State *state);
@

Preconditioned fermions may be exported back to the user.
We also use a functional interface to provide indexing.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_export_half_fermion(void (*writer)(const int pos[4],
                                                      int color,
                                                      int dirac,
                                                      int re_im,
                                                      double value,
                                                      void *env),
                                      void *env,
                                      const struct QOP_F|:Nc:|_CLOVER_HalfFermion *hfermion);
int `QOP_D|:Nc:|_CLOVER_export_half_fermion(void (*writer)(const int pos[4],
                                                      int color,
                                                      int dirac,
                                                      int re_im,
                                                      double value,
                                                      void *env),
                                      void *env,
                                      const struct QOP_D|:Nc:|_CLOVER_HalfFermion *hfermion);
@

We also need a couple of destructors for fermion fields. For convenience, they
will accept [[NULL]] intead of a valid fermion field.
<<Interface functions>>=
void `QOP_F|:Nc:|_CLOVER_free_half_fermion(struct QOP_F|:Nc:|_CLOVER_HalfFermion **hfermion_ptr);
void `QOP_D|:Nc:|_CLOVER_free_half_fermion(struct QOP_D|:Nc:|_CLOVER_HalfFermion **hfermion_ptr);
@

Finally, macros for prefered precision
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_import_half_fermion QOP_F|:Nc:|_CLOVER_import_half_fermion
#define `QOP_|:Nc:|_CLOVER_export_half_fermion QOP_F|:Nc:|_CLOVER_export_half_fermion
#define `QOP_|:Nc:|_CLOVER_allocate_half_fermion QOP_F|:Nc:|_CLOVER_allocate_half_fermion
#define `QOP_|:Nc:|_CLOVER_free_half_fermion QOP_F|:Nc:|_CLOVER_free_half_fermion
#define `QOP_|:Nc:|_CLOVER_HalfFermion QOP_F|:Nc:|_CLOVER_HalfFermion
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_import_half_fermion QOP_D|:Nc:|_CLOVER_import_half_fermion
#define `QOP_|:Nc:|_CLOVER_export_half_fermion QOP_D|:Nc:|_CLOVER_export_half_fermion
#define `QOP_|:Nc:|_CLOVER_allocate_half_fermion QOP_D|:Nc:|_CLOVER_allocate_half_fermion
#define `QOP_|:Nc:|_CLOVER_free_half_fermion QOP_D|:Nc:|_CLOVER_free_half_fermion
#define `QOP_|:Nc:|_CLOVER_HalfFermion QOP_D|:Nc:|_CLOVER_HalfFermion
@

\section{Dirac Operator}
We provide both normal and conjugated Dirac Operator for the full fermion as
well as the precondition operator and its conjugate both in single and double
precision.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_D_operator(struct QOP_F|:Nc:|_CLOVER_Fermion *result,
                              const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                              const struct QOP_F|:Nc:|_CLOVER_Fermion *fermion);
int `QOP_D|:Nc:|_CLOVER_D_operator(struct QOP_D|:Nc:|_CLOVER_Fermion *result,
                              const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                              const struct QOP_D|:Nc:|_CLOVER_Fermion *fermion);
@
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_D_operator_conjugated(struct QOP_F|:Nc:|_CLOVER_Fermion *result,
                                         const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                                         const struct QOP_F|:Nc:|_CLOVER_Fermion *fermion);
int `QOP_D|:Nc:|_CLOVER_D_operator_conjugated(struct QOP_D|:Nc:|_CLOVER_Fermion *result,
                                         const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                                         const struct QOP_D|:Nc:|_CLOVER_Fermion *fermion);
@
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_M_operator(struct QOP_F|:Nc:|_CLOVER_HalfFermion *result,
                           const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                           const struct QOP_F|:Nc:|_CLOVER_HalfFermion *fermion);
int `QOP_D|:Nc:|_CLOVER_M_operator(struct QOP_D|:Nc:|_CLOVER_HalfFermion *result,
                           const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                           const struct QOP_D|:Nc:|_CLOVER_HalfFermion *fermion);
@
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_M_operator_conjugated(struct QOP_F|:Nc:|_CLOVER_HalfFermion *result,
                                      const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                                      const struct QOP_F|:Nc:|_CLOVER_HalfFermion *fermion);
int `QOP_D|:Nc:|_CLOVER_M_operator_conjugated(struct QOP_D|:Nc:|_CLOVER_HalfFermion *result,
                                      const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                                      const struct QOP_D|:Nc:|_CLOVER_HalfFermion *fermion);
@

Also the default precision macros
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_D_operator QOP_F|:Nc:|_CLOVER_D_operator
#define `QOP_|:Nc:|_CLOVER_D_operator_conjugated QOP_F|:Nc:|_CLOVER_D_operator_conjugated
#define `QOP_CLOVER_M_operator QOP_F|:Nc:|_CLOVER_M_operator
#define `QOP_CLOVER_M_operator_conjugated QOP_F|:Nc:|_CLOVER_M_operator_conjugated
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_D_operator QOP_D|:Nc:|_CLOVER_D_operator
#define `QOP_|:Nc:|_CLOVER_D_operator_conjugated QOP_D|:Nc:|_CLOVER_D_operator_conjugated
#define `QOP_CLOVER_M_operator QOP_D|:Nc:|_CLOVER_M_operator
#define `QOP_CLOVER_M_operator_conjugated QOP_D|:Nc:|_CLOVER_M_operator_conjugated
@
\section{Deflation}
For delfation solvers, the following interface is provided. Deflators are used
by the deflation solvers to keep low eigenvalue vector space. Low eigenmode space 
can be either accumulated while solving Dirac equations (EigCG) or loaded into 
a deflator. There are two way to load vectors: one by one or as a blas matrix.
In the latter case, a BLAS matrix must be pre-allocated as 
[[(...)_HalfFermionMat]] and filled following the site/spin/color conventions 
compatible with [[(...)_blas_from_half_fermion]]. In practice, such a matrix is 
allocated and used in Lanczos iterations, and later supplied to create a deflator 
object; in-place conversion helps to avoid copying vectors and allocating the 
associated memory twice. Vectors may be exported from the deflator one by one.
Currently, only single precision deflator is built by default.

The state of the deflator is packaged into an opaque structure:
<<Interface types>>=
struct `QOP_F|:Nc:|_CLOVER_Deflator;
@

The deflators are created with given capacity, size and precision:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_create_deflator(struct QOP_F|:Nc:|_CLOVER_Deflator **defl_ptr,
                               struct QOP_|:Nc:|_CLOVER_State *state,
                               int nev, int vsize, double eps, int umax);
@

Alternatively, one can use a user-filled BLAS matrix (sequence of BLAS vectors),
from which the first [[hfm_nev]] vectors are used for deflation, and the
remaining space in the allocated matrix may be filled with additional vectors
from EigCG (but not to exceed [[eigcg_umax]]). Workspace for EigCG is allocated
if and only if [[eigcg_vmax]], [[eigcg_nev]] $>0$:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_create_deflator_inplace(struct QOP_F|:Nc:|_CLOVER_Deflator       **defl_ptr,
                                        const struct QOP_F|:Nc:|_CLOVER_Gauge    *gauge,
                                        struct QOP_F|:Nc:|_CLOVER_HalfFermionMat **hfm_ptr,
                                        int                               hfm_nev,
                                        int                               eigcg_vmax,
                                        int                               eigcg_nev,
                                        double                            eigcg_eps,
                                        int                               eigcg_umax);
@

The BLAS-like space handler [[hfm_ptr]] has an opaque type
<<Interface types>>=
struct `QOP_F|:Nc:|_CLOVER_HalfFermionMat;
@
and must be preallocated by the function
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_alloc_half_fermion_matrix(struct QOP_F|:Nc:|_CLOVER_HalfFermionMat **hfm_ptr,
                                             struct QOP_|:Nc:|_CLOVER_State *state,
                                             int ncol);
@
A [[HalfFermionMat]] object is essentially a wrapper for a BLAS-style matrix; 
to use it as such, the following function provides a raw pointer to the data, 
together with the number of rows and columns and the ``leading dimension'' 
of the array:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_blas_view_half_fermion_matrix(struct QOP_F|:Nc:|_CLOVER_HalfFermionMat *hfm_ptr,
                                                int        *nrow_loc,
                                                int        *ncol,
                                                float      **blas_ptr,
                                                int        *blas_ld);
@
The element order in the matrix conforms to [[FORTRAN]] conventions, that is
\begin{eqnarray*}
\mathrm{Re } M_{ij} &=& (*\mathtt{blas\_ptr})[2*i + 2*j*\mathtt{blas\_ld}]\,,\\
\mathrm{Im } M_{ij} &=& (*\mathtt{blas\_ptr})[2*i + 2*j*\mathtt{blas\_ld} + 1]\,,\\
& & 0\le i<\mathtt{nrow\_loc},\quad 0\le j<\mathtt{ncol}\,,
\end{eqnarray*}
and [[nrow_loc]] is the local vector size (complex numbers per process). 
The $j$-th column represents the $j$-th vector.
Once a [[HalfFermionMat]] object is used to create a deflator, it cannot be 
reused since its allocated memory belongs to the new deflator. For this reason,
[[create_deflator_inplace]] actually deallocates the associated storage structures
and sets [[*hfm_ptr]] to [[NULL]]. The following function may be called 
to manually deallocate a [[HalfFermionMat]] object ([[NULL]] pointer-safe):
<<Interface functions>>=
void QOP_F|:Nc:|_CLOVER_free_half_fermion_matrix(struct QOP_F|:Nc:|_CLOVER_HalfFermionMat **hfm_ptr);
@

Once done, the deflators must be freed with the following functions:
<<Interface functions>>=
void `QOP_F|:Nc:|_CLOVER_free_deflator(struct QOP_F|:Nc:|_CLOVER_Deflator **defl_ptr);
@

\textbf{Functions to control the state of the deflator.}
If one needs to keep the handle
but purge the accumulated data, there is a [[reset]] operation:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_eigcg_reset(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@

To control collection of the Krylov space, use [[eigcg_stop]] and [[eigcg_resume]]. While
the EigCG is stopped, it can still be used in the deflated solver and
queried about accumulated eigenvalues.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_eigcg_stop(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
int `QOP_F|:Nc:|_CLOVER_deflator_eigcg_resume(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@
The following fuction may be used to inquire the state of EigCG:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_eigcg_is_stopped(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@

The current dimension of low space may be requested from the deflator:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_current_dim(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@

Extract a vector from the deflator. If the vector index is out of range, nothing is
written into memory and a non-zero value is returned.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_extract_vector(struct QOP_F|:Nc:|_CLOVER_HalfFermion *hfermion_ptr,
                                          const struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr,
                                          int idx);
@

Before adding vectors to the deflator, it must be marked to prevent accidental 
changes to the deflator state
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_start_load(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@

Manually add a vector to the deflator. Zero value is returned if the insersion was a success.
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_add_vector(const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                                    struct QOP_F|:Nc:|_CLOVER_Deflator *deflator,
                                    const struct QOP_F|:Nc:|_CLOVER_HalfFermion *hfermion);
@

After a set of vector is loaded, the deflator should be released before using it in an inverter
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_stop_load(struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@

The deflator can return its current estimate of the eigenvalues if it has it.
There are either [[nev]] eigenmode estimates, or none. If the deflator does
not have the estimates, [[eigen]] returns [[1]], otherwise it
returns [[0]].
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_deflator_eigen(int n, double *eigen_values,
                              struct QOP_F|:Nc:|_CLOVER_Deflator *defl_ptr);
@

\section{Solvers}
We provide three solvers for the Dirac operator. All solvers can optionally
compute true CG and Dirac residuals on each iteration. Constants below can be
bitwise combined to select which residual are computed and printed. The
behavior of the solvers do not change when residuals are selected. Applications
should not assume particular values of the constants except that
[[QOP_|:Nc:|_CLOVER_LOG_NONE]] is zero.
<<Interface types>>=
enum {
   `QOP_CLOVER_LOG_NONE              = 0x00,
   `QOP_CLOVER_LOG_CG_RESIDUAL       = 0x01,
   `QOP_CLOVER_LOG_TRUE_RESIDUAL     = 0x02,
   `QOP_CLOVER_FINAL_CG_RESIDUAL     = 0x04,
   `QOP_CLOVER_FINAL_DIRAC_RESIDUAL  = 0x08,
   `QOP_CLOVER_LOG_EIG_UPDATE1       = 0x10,
   `QOP_CLOVER_LOG_EIG_POSTAMBLE     = 0x20,
   `QOP_CLOVER_LOG_EVERYTHING        = 0x3f
};
@

First, the convenience routine to solve $D_{CL}\psi=\eta$. At most
[[max_iterations]] are performed, the CG stops when it finds a vector $\psi_e$
close enough to the solution in the following sense:
\[
    ||M^{\dagger}M\psi_e - \chi_e||^2 < \epsilon ||\chi_e||^2,
\]
see Eq.~(\ref{normal-eq}) in section~\ref{precond}.

If conjugate gradient converges, zero is returned. In this case
[[out_iterations]] contains the number of iterations and [[out_epsilon]]
contains normalized iterative CG residual.

<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_D_CG(struct QOP_F|:Nc:|_CLOVER_Fermion *result,
                        int *out_iterations,
                        double *out_epsilon,
                        const struct QOP_F|:Nc:|_CLOVER_Fermion *chi_0,
                        const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                        const struct QOP_F|:Nc:|_CLOVER_Fermion *rhs,
                        int max_iteration,
                        double epsilon,
                        unsigned int options);
int `QOP_D|:Nc:|_CLOVER_D_CG(struct QOP_D|:Nc:|_CLOVER_Fermion *result,
                        int *out_iterations,
                        double *out_epsilon,
                        const struct QOP_D|:Nc:|_CLOVER_Fermion *x_0,
                        const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                        const struct QOP_D|:Nc:|_CLOVER_Fermion *rhs,
                        int max_iteration,
                        double epsilon,
                        unsigned int options);
@

The even-odd preconditioned CG solver is itself accessible using these
routines:
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_MxM_CG(struct QOP_F|:Nc:|_CLOVER_HalfFermion *result,
                          int *out_iterations,
                          double *out_epsilon,
                          const struct QOP_F|:Nc:|_CLOVER_HalfFermion *chi_0,
                          const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                          const struct QOP_F|:Nc:|_CLOVER_HalfFermion *rhs,
                          int max_iteration,
                          double epsilon,
                          unsigned int options);
int `QOP_D|:Nc:|_CLOVER_MxM_CG(struct QOP_D|:Nc:|_CLOVER_HalfFermion *result,
                          int *out_iterations,
                          double *out_epsilon,
                          const struct QOP_D|:Nc:|_CLOVER_HalfFermion *x_0,
                          const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                          const struct QOP_D|:Nc:|_CLOVER_HalfFermion *rhs,
                          int max_iteration,
                          double epsilon,
                          unsigned int options);
@

The mixed precision solver uses the trick communicated by Stefan Krieg: run the
CG in single precision while accumulating the result in double. It has only
a double precision version and takes two extra parameter [[f_iterations]] and
[[f_epsilon]] which control the number of float CG iterations between double
updates.
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_mixed_D_CG(struct QOP_D|:Nc:|_CLOVER_Fermion *result,
                           int *out_iterations,
                           double *out_epsilon,
                           const struct QOP_D|:Nc:|_CLOVER_Fermion *x_0,
                           const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                           const struct QOP_D|:Nc:|_CLOVER_Fermion *rhs,
                           int f_iterations,
                           double f_epsilon,
                           int max_iteration,
                           double epsilon,
                           unsigned int options);
@                      

A mixed precision deflated solver is provided. The interface is basically
the same as the plain mixed solver above with addition of an extra parameter
for the deflator state.

<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_deflated_mixed_D_CG(struct QOP_D|:Nc:|_CLOVER_Fermion *result,
                                   int *out_iterations,
                                   double *out_epsilon,
                                   const struct QOP_D|:Nc:|_CLOVER_Fermion *chi_0,
                                   const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                                   const struct QOP_D|:Nc:|_CLOVER_Fermion *rhs,
                                   struct QOP_F|:Nc:|_CLOVER_Deflator *deflator,
                                   int f_iterations,
                                   double f_epsilon,
                                   int max_iteration,
                                   double epsilon,
                                   unsigned int options);
@

Again, macros
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_D_CG QOP_F|:Nc:|_CLOVER_D_CG
#define `QOP_|:Nc:|_CLOVER_MxM_CG QOP_F|:Nc:|_CLOVER_MxM_CG
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_D_CG QOP_D|:Nc:|_CLOVER_D_CG
#define `QOP_|:Nc:|_CLOVER_MxM_CG QOP_D|:Nc:|_CLOVER_MxM_CG
@

\section{Preconditioned operator functions}
Apply an $n\geq1$ degree polynomial of $M^\dagger M$ to vector $\psi$. The polynomial is defined
using the general three-term recurrence relation

\begin{eqnarray*}
P_0(M^\dagger M)\psi & = & c_0 \psi \\
P_1(M^\dagger M)\psi & = & a_0 \psi + b_0 M^\dagger M \psi \\
P_n(M^\dagger M)\psi & = & (a_{n-1} + b_{n-1} M^\dagger M) P_{n-1}(M^\dagger M)\psi 
        + c_{n-1} P_{n-2}(M^\dagger M)\psi,\quad n > 1
\end{eqnarray*}

The value of $P_n(M^\dagger M)\psi$ is returned in [[result]], and if
[[result_prev]] is not [[NULL]], it shall contain the value of
$P_{n-1}(M^\dagger M)\psi$ on return.  Functions below compute operator
polynomials for positive [[n]]. Arrays [[a]], [[b]], and [[c]] contain
recursion coefficients and must be at least of length [[n]].

<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_MxM_poly(struct QOP_F|:Nc:|_CLOVER_HalfFermion *result,
                         struct QOP_F|:Nc:|_CLOVER_HalfFermion *result_prev,
                         const struct QOP_F|:Nc:|_CLOVER_Gauge *gauge,
                         const struct QOP_F|:Nc:|_CLOVER_HalfFermion *psi,
                         int n,
                         const double a[/* n */],
                         const double b[/* n */],
                         const double c[/* n */]);
int `QOP_D|:Nc:|_CLOVER_MxM_poly(struct QOP_D|:Nc:|_CLOVER_HalfFermion *result,
                         struct QOP_D|:Nc:|_CLOVER_HalfFermion *result_prev,
                         const struct QOP_D|:Nc:|_CLOVER_Gauge *gauge,
                         const struct QOP_D|:Nc:|_CLOVER_HalfFermion *psi,
                         int n,
                         const double a[/* n */],
                         const double b[/* n */],
                         const double c[/* n */]);
@
The macros for default precision:
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_MxM_poly QOP_F|:Nc:|_CLOVER_MxM_poly
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_MxM_poly QOP_D|:Nc:|_CLOVER_MxM_poly
@

Since polynomials may have values that can cause overflow of 
floating point operations, it may be necessary to rescale these 
polynomials to some finite value.
The following function rescales the coefficients [[a]], [[b]], [[c]]
so that all the polynomials are equal to 1 at some point $x_0$, 
unless they have absolute values smaller than [[tol]]:
<<Interface functions>>=
int `QOP_|:Nc:|_CLOVER_poly_normalize(int n,
                              double a[/* n */],
                              double b[/* n */],
                              double c[/* n */],
                              double x0,
                              double tol);
@

\section{Helper routines}
To avoid excessive export and import calls, we provide the following linear
algebra on full and preconditioned fermions.
\[
r\leftarrow a + \alpha b
\]
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_madd_fermion(struct QOP_F|:Nc:|_CLOVER_Fermion *r,
                                const struct QOP_F|:Nc:|_CLOVER_Fermion *a,
                                double alpha,
                                const struct QOP_F|:Nc:|_CLOVER_Fermion *b);
int `QOP_D|:Nc:|_CLOVER_madd_fermion(struct QOP_D|:Nc:|_CLOVER_Fermion *r,
                                const struct QOP_D|:Nc:|_CLOVER_Fermion *a,
                                double alpha,
                                const struct QOP_D|:Nc:|_CLOVER_Fermion *b);
int `QOP_F|:Nc:|_CLOVER_madd_half_fermion(struct QOP_F|:Nc:|_CLOVER_HalfFermion *r,
                                     const struct QOP_F|:Nc:|_CLOVER_HalfFermion *a,
                                     double alpha,
                                     const struct QOP_F|:Nc:|_CLOVER_HalfFermion *b);
int `QOP_D|:Nc:|_CLOVER_madd_half_fermion(struct QOP_D|:Nc:|_CLOVER_HalfFermion *r,
                                     const struct QOP_D|:Nc:|_CLOVER_HalfFermion *a,
                                     double alpha,
                                     const struct QOP_D|:Nc:|_CLOVER_HalfFermion *b);
@
\[
  \alpha \leftarrow \langle a,b\rangle
\]
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_dot_fermion(double *r_re,
                               double *r_im,
                               const struct QOP_F|:Nc:|_CLOVER_Fermion *a,
                               const struct QOP_F|:Nc:|_CLOVER_Fermion *b);
int `QOP_D|:Nc:|_CLOVER_dot_fermion(double *r_re,
                               double *r_im,
                               const struct QOP_D|:Nc:|_CLOVER_Fermion *a,
                               const struct QOP_D|:Nc:|_CLOVER_Fermion *b);
int `QOP_F|:Nc:|_CLOVER_dot_half_fermion(double *r_re,
                                    double *r_im,
                                    const struct QOP_F|:Nc:|_CLOVER_HalfFermion *a,
                                    const struct QOP_F|:Nc:|_CLOVER_HalfFermion *b);
int `QOP_D|:Nc:|_CLOVER_dot_half_fermion(double *r_re,
                                    double *r_im,
                                    const struct QOP_D|:Nc:|_CLOVER_HalfFermion *a,
                                    const struct QOP_D|:Nc:|_CLOVER_HalfFermion *b);
@

\[
  \alpha \leftarrow \langle a,a\rangle
\]
<<Interface functions>>=
int `QOP_F|:Nc:|_CLOVER_norm2_fermion(double *r,
                                 const struct QOP_F|:Nc:|_CLOVER_Fermion *a);
int `QOP_D|:Nc:|_CLOVER_norm2_fermion(double *r_re,
                                 const struct QOP_D|:Nc:|_CLOVER_Fermion *a);
int `QOP_F|:Nc:|_CLOVER_norm2_half_fermion(double *r_re,
                                      const struct QOP_F|:Nc:|_CLOVER_HalfFermion *a);
int `QOP_D|:Nc:|_CLOVER_norm2_half_fermion(double *r_re,
                                      const struct QOP_D|:Nc:|_CLOVER_HalfFermion *a);
@

Also, the macros
<<Single precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_madd_fermion QOP_F|:Nc:|_CLOVER_madd_fermion
#define `QOP_|:Nc:|_CLOVER_madd_half_fermion QOP_F|:Nc:|_CLOVER_madd_half_fermion
#define `QOP_|:Nc:|_CLOVER_dot_fermion QOP_F|:Nc:|_CLOVER_dot_fermion
#define `QOP_|:Nc:|_CLOVER_dot_half_fermion QOP_F|:Nc:|_CLOVER_dot_half_fermion
#define `QOP_|:Nc:|_CLOVER_norm2_fermion QOP_F|:Nc:|_CLOVER_norm2_fermion
#define `QOP_|:Nc:|_CLOVER_norm2_half_fermion QOP_F|:Nc:|_CLOVER_norm2_half_fermion
@
<<Double precision defaults>>=
#define `QOP_|:Nc:|_CLOVER_madd_fermion QOP_D|:Nc:|_CLOVER_madd_fermion
#define `QOP_|:Nc:|_CLOVER_madd_half_fermion QOP_D|:Nc:|_CLOVER_madd_half_fermion
#define `QOP_|:Nc:|_CLOVER_dot_fermion QOP_D|:Nc:|_CLOVER_dot_fermion
#define `QOP_|:Nc:|_CLOVER_dot_half_fermion QOP_D|:Nc:|_CLOVER_dot_half_fermion
#define `QOP_|:Nc:|_CLOVER_norm2_fermion QOP_D|:Nc:|_CLOVER_norm2_fermion
#define `QOP_|:Nc:|_CLOVER_norm2_half_fermion QOP_D|:Nc:|_CLOVER_norm2_half_fermion
@

%XXX
%\chapter{CHANGES}
%\begin{tabular}{|p{72pt}|l|p{350pt}|}
%\hline
%May 17, 2008 & avp & Bug in error handling fixed. \\
%\hline
%\end{tabular}
%XXX

\appendix
\chapter{CODE CHUNKS}
\nowebchunks
\pagebreak
\chapter{SYMBOLS}
\nowebindex

\end{document}
