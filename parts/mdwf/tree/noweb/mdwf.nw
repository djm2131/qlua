\documentclass[twoside,openright]{report}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage[boxed]{algorithm2e}
%\usepackage{epsfig}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{670pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\newcommand{\Cee}{\texttt{C}}

\title{M\"obius Domain Wall Fermions Implementation}
\author{Andrew Pochinsky}
\date{X.XX.XX Termidor 18, XXXX}

\begin{document}
\maketitle
\thispagestyle{empty}\hbox{}
\vfill
\copyright 2007 Massachusetts Institute of Technology

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\pagebreak

\tableofcontents
\pagebreak

\chapter{PHYSICS}
The Domain Wall Fermion Dirac operator is defined by
\begin{equation}
\left\langle\bar\psi|D_{DW}|\psi\right\rangle =
  \sum_{x,x'}\bar\psi(x)D_{DW}(x,x')\psi(x'),
\end{equation}
where
\begin{eqnarray}
D_{DW}(x,x')  &= &D_{+}^{(s)}(x,x')\delta_{s,s'}\nonumber\\
    & & + D_{-}^{(s)}(x,x')P_{+}\delta_{s,s'+1}
       -mD_{-}^{(s)}(x,x')P_{+}\delta_{s,0}\delta_{s',L_s-1} \nonumber\\
   & &  + D_{-}^{(s)}(x,x')P_{-}\delta_{s,s'-1} 
       -mD_{-}^{(s)}(x,x')P_{-}\delta_{s,L_s-1}\delta_{s',0} \label{D_DW},\\
P_{+}&=&\frac{1+\gamma_5}{2},\\
P_{-}&=&\frac{1-\gamma_5}{2},\\
D_{+}^{(s)}(x,x')&=&b_5(s)D_W(x,x')+1,\\
D_{-}^{(s)}(x,x')&=&c_5(s)D_W(x,x')-1,
\end{eqnarray}
and
\begin{equation}
D_W(x,x')=(4+M_5)\delta_{x,x'}
 -\frac{1}{2}\sum_{\mu=0}^{3}
    \left[(1-\gamma_\mu)U_\mu(x)\delta_{x,x'-\hat\mu}
         +(1+\gamma_\mu)U_\mu^{\dagger}(x-\hat\mu)\delta_{x,x'+\hat\mu}\right]
\end{equation}
is the standard Wilson action.

\section{Gamma Matrices}
We use the same $\gamma$-matrix basis as Chroma to simplify conversion between
two codes. The choice below could be changed with a few modifications to the
rest of the code, if $\gamma_5$ is kept diagonal, and one of other
$\gamma$-matrices has all nonzero entries equal to $+1$.

In the $\gamma$-basis defined below one has
\begin{equation}
\gamma_5 = \gamma_0 \gamma_1 \gamma_2 \gamma_3 = \sigma_3 \otimes 1 =
           \left(\begin{array}{cc}
             1 & 0 \\
             0 & -1
           \end{array}\right) =
           \left(\begin{array}{cccc}
             1 & 0 & 0 & 0\\
             0 & 1 & 0 & 0\\
             0 & 0 &-1 & 0\\
             0 & 0 & 0 &-1
           \end{array}\right)
\end{equation}
Fragments for $\gamma_\mu$ below are not the most fool-proof, but they should do
for now.

\pagebreak
\begin{equation}
\gamma_0 = -\sigma_2 \otimes \sigma_1  =
           \left(\begin{array}{cc}
                0&i\sigma_1\\
                -i\sigma_1&0
             \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&0&i\\
                                 0&0&i&0\\
                                 0&-i&0&0\\
                                 -i&0&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_0)$>>=
((project 0 plus) . ((plus-one 0 plus-i 3)
                     (plus-one 1 plus-i 2)))
@
<<Unproject $(1+\gamma_0)$>>=
((unproject 0 plus) . ((plus-one 0)
                       (plus-one 1)
                       (minus-i 1)
                       (minus-i 0)))
@
<<Project $(1-\gamma_0)$>>=
((project 0 minus) . ((plus-one 0 minus-i 3)
                      (plus-one 1 minus-i 2)))
@
<<Unproject $(1-\gamma_0)$>>=
((unproject 0 minus) . ((plus-one 0)
                        (plus-one 1)
                        (plus-i 1)
                        (plus-i 0)))
@

\pagebreak
\begin{equation}
\gamma_1 = \sigma_2 \otimes \sigma_2  = 
           \left(\begin{array}{cc}
                  0 & -i\sigma_2\\
                  i\sigma_2 & 0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&0&-1\\
                                 0&0&1&0\\
                                 0&1&0&0\\
                                 -1&0&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_1)$>>=
((project 1 plus) . ((plus-one 0 minus-one 3)
                     (plus-one 1 plus-one 2)))
@
<<Unproject $(1+\gamma_1)$>>=
((unproject 1 plus) . ((plus-one 0)
                       (plus-one 1)
                       (plus-one 1)
                       (minus-one 0)))
@
<<Project $(1-\gamma_1)$>>=
((project 1 minus) . ((plus-one 0 plus-one 3)
                      (plus-one 1 minus-one 2)))
@
<<Unproject $(1-\gamma_1)$>>=
((unproject 1 minus) . ((plus-one 0)
                        (plus-one 1)
                        (minus-one 1)
                        (plus-one 0)))
@

\pagebreak
\begin{equation}
\gamma_2 = -\sigma_2 \otimes \sigma_3  = 
           \left(\begin{array}{cc}
                   0 & i\sigma_3\\
                 -i\sigma_3&0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&i&0\\
                                 0&0&0&-i\\
                                 -i&0&0&0\\
                                 0&i&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_2)$>>=
((project 2 plus) . ((plus-one 0 plus-i 2)
                     (plus-one 1 minus-i 3)))
@
<<Unproject $(1+\gamma_2)$>>=
((unproject 2 plus) . ((plus-one 0)
                       (plus-one 1)
                       (minus-i 0)
                       (plus-i 1)))
@
<<Project $(1-\gamma_2)$>>=
((project 2 minus) . ((plus-one 0 minus-i 2)
                      (plus-one 1 plus-i 3)))
@
<<Unproject $(1-\gamma_2)$>>=
((unproject 2 minus) . ((plus-one 0)
                        (plus-one 1)
                        (plus-i 0)
                        (minus-i 1)))
@

\pagebreak
\begin{equation}
\gamma_3 = \sigma_1 \otimes 1 =
           \left(\begin{array}{cc}
                  0 & 1\\
                  1 & 0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&1&0\\
                                 0&0&0&1\\
                                 1&0&0&0\\
                                 0&1&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_3)$>>=
((project 3 plus) . ((plus-one 0 plus-one 2)
                     (plus-one 1 plus-one 3)))
@
<<Unproject $(1+\gamma_3)$>>=
((unproject 3 plus) . ((plus-one 0)
                       (plus-one 1)
                       (plus-one 0)
                       (plus-one 1)))
@
This is our starting point in sums over directions
<<Start $\mu$ sum>>=
(define mdwf-start-sum-dimension 3)
(define mdwf-start-sum-direction 'plus)
@

<<Project $(1-\gamma_3)$>>=
((project 3 minus) . ((plus-one 0 minus-one 2)
                      (plus-one 1 minus-one 3)))
@
<<Unproject $(1-\gamma_3)$>>=
((unproject 3 minus) . ((plus-one 0)
                        (plus-one 1)
                        (minus-one 0)
                        (minus-one 1)))
@

Now let us collect the $\gamma$-matrix projections and reconstructions. We
put them all together into [[mdwf-basis]] as an a list of pairs with keys
of the form [[(<op> <dir> <sign>)]].
<<Scheme definitions>>=
(define mdwf-basis '(
  <<Project $(1+\gamma_0)$>>
  <<Project $(1+\gamma_1)$>>
  <<Project $(1+\gamma_2)$>>
  <<Project $(1+\gamma_3)$>>
  <<Project $(1-\gamma_0)$>>
  <<Project $(1-\gamma_1)$>>
  <<Project $(1-\gamma_2)$>>
  <<Project $(1-\gamma_3)$>>
  <<Unproject $(1+\gamma_0)$>>
  <<Unproject $(1+\gamma_1)$>>
  <<Unproject $(1+\gamma_2)$>>
  <<Unproject $(1+\gamma_3)$>>
  <<Unproject $(1-\gamma_0)$>>
  <<Unproject $(1-\gamma_1)$>>
  <<Unproject $(1-\gamma_2)$>>
  <<Unproject $(1-\gamma_3)$>>))
@

We also define a starting link in a sum over links:
<<Scheme definitions>>=
<<Start $\mu$ sum>>
@

Here is a module for PLT:
<<File [[../utils/basis.ss]]>>=
(module basis
        mzscheme
   (provide mdwf-basis
            mdwf-start-sum-dimension
            mdwf-start-sum-direction)
   <<Scheme definitions>>
)
@

\pagebreak\section{Preconditioning}
We use four dimensional preconditioner to improve convergence of the CG.
Following Kostas Orginos, let us color the lattice sites according to the
parity of $x_0+x_1+x_2+x_3$. Then we can rewrite $D_{DW}$ from Eq.~(\ref{D_DW})
as follows:
\begin{equation}\label{EO-form}
D_{DW}=\left(\begin{array}{cc}
A_{oo} & F_{oe}B_{ee}\\
F_{eo}B_{oo} & A_{ee}
\end{array}\right),
\end{equation}
where
\begin{eqnarray}
A_{oo}(x,x') & = &\left\{(c_5(s)(M_5+4)-1)\left[P_{+}\delta_{s,s'+1}
       - mP_{+}\delta_{s,0}\delta_{s',L_s-1}
              +P_{-}\delta_{s,s'-1}
       -mP_{-}\delta_{s,L_s-1}\delta_{s',0}\right]\right.\nonumber\\
      && \left.+(b_5(s)(M_5+4)+1)\delta_{s,s'}\right\}\delta_{x,x'},\\
B_{oo}(x,x') & = & \left\{c_5(s)\left[P_{+}\delta_{s,s'+1}
     - mP_{+}\delta_{s,0}\delta_{s',L_s-1}
                +P_{-}\delta_{s,s'-1}
       -mP_{-}\delta_{s,L_s-1}\delta_{s',0}\right]+
       b_5(s)\delta_{s,s'}\right\}\delta_{x,x'},\\
F_{oe}(x,x') &=&-\frac{\delta_{s,s'}}{2}
            \sum_{\mu=0}^{3}\left[(1-\gamma_\mu)U_\mu(x)\delta_{x,x'-\hat\mu}
         +(1+\gamma_\mu)U_\mu^{\dagger}(x-\hat\mu)\delta_{x,x'+\hat\mu}\right],
\end{eqnarray}
and similary for other parity components. (On the LHS $x$ and $x'$ are 5-d
indices, hereafter spinor and color indices are suppressed but presumed.)

Let us rewrite Eq.~(\ref{EO-form}) as follows:
\begin{equation}
D_{DW}=
\left(\begin{array}{cc}
I_{oo} & 0\\
F_{eo}B_{oo}A_{oo}^{-1} & A_{ee}B_{ee}^{-1}
\end{array}\right)
\left(\begin{array}{cc}
A_{oo} & F_{oe}\\
0 & I_{ee}-B_{ee}A_{ee}^{-1}F_{eo}B_{oo}A_{oo}^{-1}F_{oe}
\end{array}\right)
\left(\begin{array}{cc}
I_{oo} & 0\\
0 & B_{ee}
\end{array}\right).
\end{equation}

To solve the equation
\[
D_{DW}\psi=
\left(\begin{array}{cc}
A_{oo} & F_{oe}B_{ee}\\
F_{eo}B_{oo} & A_{ee}
\end{array}\right)
\left(\begin{array}{c}\psi_o\\\psi_e\end{array}\right) =
   \left(\begin{array}{c}\eta_o\\\eta_e\end{array}\right),
\]
one performs the following steps:
\begin{enumerate}
\item Use $M=I_{ee}-B_{ee}A_{ee}^{-1}F_{eo}B_{oo}A_{oo}^{-1}F_{oe}$ in the
following.
\item Use $M^\dagger=I_{ee}-\left(F_{oe}\right)^\dagger
\left(A_{oo}^{-1}\right)^\dagger
\left(B_{oo}\right)^\dagger
\left(F_{eo}\right)^\dagger
\left(A_{ee}^{-1}\right)^\dagger
\left(B_{ee}\right)^\dagger$ in the following.
\item Compute
\[
\chi_e =M^{\dagger} B_{ee}A_{ee}^{-1}\left(\eta_e
            - F_{eo}B_{oo}A_{oo}^{-1}\eta_o\right).
\]
\item Solve
\[
M^{\dagger}M\xi_e = \chi_e
\]
for $\xi_e$ using Alg.~\ref{real}.
\item Compute
\begin{eqnarray}
\psi_o &=& A_{oo}^{-1}\left(\eta_o-F_{oe}\xi_e\right),\\
\psi_e &=& B_{ee}^{-1}\xi_e.
\end{eqnarray}
\end{enumerate}

\pagebreak
\section{Inverting $A$ and $B$}
Note that $A$ and $B$ have the following form:
\begin{eqnarray}
A(x,x') &=& \left[A_{+}(s,s')P_{+}+A_{-}(s,s')P_{-}\right]\delta_{x,x'}\\
B(x,x') &=& \left[B_{+}(s,s')P_{+}+B_{-}(s,s')P_{-}\right]\delta_{x,x'}
\end{eqnarray}
where
\begin{eqnarray}
\label{A+}
A_{+}(s,s') & = &u_\alpha(s)\delta_{s,s'+1}
                  +v_\alpha(s)\delta_{s,0}\delta_{s',L_s-1}
                  +w_\alpha(s)\delta_{s,s'},\\
\label{A-}
A_{-}(s,s') & = &u_\alpha(s)\delta_{s,s'-1}
                  +v_\alpha(s)\delta_{s,L_s-1}\delta_{s',0}
                  +w_\alpha(s)\delta_{s,s'},\\
\label{B+}
B_{+}(s,s') & = &u_\beta(s)\delta_{s,s'+1}
                  +v_\beta(s)\delta_{s,0}\delta_{s',L_s-1}
                  +w_\beta(s)\delta_{s,s'},\\
\label{B-}
B_{-}(s,s') & = &u_\beta(s)\delta_{s,s'-1}
                  +v_\beta(s)\delta_{s,L_s-1}\delta_{s',0}
                  +w_\beta(s)\delta_{s,s'};
\end{eqnarray}
and
\begin{eqnarray}
u_\alpha(s) &=&c_5(s)(M_5+4)-1,\\
v_\alpha(s)  &=&-m u_\alpha(s),\\
w_\alpha(s) &=&b_5(s)(M_5+4)+1,\\
u_\beta(s) &=&c_5(s),\\
v_\beta(s)  &=&-m u_\beta(s),\\
w_\beta(s) &=&b_5(s).
\end{eqnarray}
This allows us to invert $A$ and $B$ as follows.

For $A_{+}$ one has (formulae for $B_{+}$ are obtained by replacing
$\alpha$ with $\beta$, see Eqs.~(\ref{A+}) and~(\ref{B+})):
\begin{equation}
A_{+} = A_{Y+} A_{L+} = 
\left(\begin{array}{cccccc}
 w_\alpha(0) & 0 & 0 & \cdots & 0 & v_\alpha(0)\\
 u_\alpha(1) & w_\alpha(1) & 0 & \cdots & 0 & 0\\
 0 & u_\alpha(2) & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & 0\\
 0 & 0 & 0 & \cdots & u_\alpha(L_s-1) & w_\alpha(L_s-1)
\end{array}\right),
\end{equation}
\begin{equation}
A_{L+} =
\left(\begin{array}{cccccc}
 1 & 0 & 0 & \cdots & 0 & 0\\
 u_\alpha(1) & w_\alpha(1) & 0 & \cdots & 0 & 0\\
 0 & u_\alpha(2) & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots  \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & 0\\
 0 & 0 & 0 & \cdots & u_\alpha(L_s-1) & w_\alpha(L_s-1)
\end{array}\right),
\end{equation}
\begin{equation}
A_{Y+} =
\left(\begin{array}{ccccc}
1/z^{(+)}_\alpha
 & a^{(+)}_\alpha(1)
 & \cdots
 & a^{(+)}_\alpha(Ls-2)
 & a^{(+)}_\alpha(Ls-1) \\
0 & 1 & \cdots & 0 & 0 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & 0 \\
0 & 0 & \cdots & 0 & 1 
\end{array}\right).
\end{equation}
For the following it is convenient to define
\begin{eqnarray}
a^{(+)}_\alpha(Ls-1) &=& -\frac{v_\alpha(0)}{w_\alpha(L_s-1)}, \\
a^{(+)}_\alpha(k) &=& - \frac{a^{(+)}_\alpha(k+1)u_\alpha(k)}{w_\alpha(k)}, \\
z^{(+)}_\alpha & = & \frac{1}{w_\alpha(0)(1-a^{(+)}_\alpha(0))},\\
b^{(+)}_\alpha(k) &=& - \frac{u_\alpha(k)}{w_\alpha(k)}, \\
c^{(+)}_\alpha(k) &=& \frac{1}{w_\alpha(k)}.
\end{eqnarray}

Then algorithm~\ref{inv-upper} could be used to compute
$\phi\leftarrow A_+^{-1}\psi$.
\IncMargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$z$, precomputed part of $A_{Y+}$}
\KwIn{$a$, precomputed part of $A_{Y+}$}
\KwIn{$b$, precomputed part of $A_{L+}$}
\KwIn{$c$, precomputed part of $A_{L+}$}
\KwIn{$\psi$, the right hand side}
\KwIn{$L_s$, flavor dimension}
\KwOut{$\phi$, the result}
\DontPrintSemicolon
\Begin{
  $\eta\leftarrow\psi_0$\;
  $k\leftarrow1$\;
  \For{$k<L_s$}{
    $\eta \leftarrow \eta + a_k\psi_k$\;
    $k\leftarrow k + 1$\;
  }
  $\phi_0\leftarrow\eta\leftarrow z \eta$\;
  $k\leftarrow1$\;
  \For{$k<L_s$}{
     $\phi_k\leftarrow\eta\leftarrow b_k \eta + c_k \psi_k$\;
     $k\leftarrow k + 1$\;
  }
  \Return{$\phi$}.
}
\caption{\label{inv-upper}Computing the inverse of $A_+$.}
\end{algorithm}
\DecMargin{20pt}

For $A_{-}$ we have the following (once again, $B_{-}$ is similar.)
\begin{equation}
A_{-} = A_{Y-} A_{L-} = 
\left(\begin{array}{cccccc}
 w_\alpha(0) & u_\alpha(0) & 0 & \cdots & 0 & 0\\
 0 & w_\alpha(1) & u_\alpha(1) & \cdots & 0 & 0\\
 0 & 0 & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & u_\alpha(L_s-2)\\
 v_\alpha(L_s-1) & 0 & 0 & \cdots & 0 & w_\alpha(L_s-1)
\end{array}\right),
\end{equation}
\begin{equation}
A_{L-} =
\left(\begin{array}{cccccc}
 w_\alpha(0) & u_\alpha(0) & 0 & \cdots & 0 & 0\\
 0 & w_\alpha(1) & u_\alpha(1) & \cdots & 0 & 0\\
 0 & 0 & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & u_\alpha(L_s-2)\\
 0 & 0 & 0 & \cdots & 0 & 1
\end{array}\right),
\end{equation}
\begin{equation}
A_{Y-} = \left(\begin{array}{ccccc}
1 & 0 & \cdots & 0 & 0 \\
0 & 1 & \cdots & 0 & 0 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & 0 \\
 a^{(-)}_\alpha(0) &
 a^{(-)}_\alpha(1) &
 \cdots &
 a^{(-)}_\alpha(L_s-2) &
 1/z^{(-)}_\alpha 
\end{array}\right).
\end{equation}
Once again, it is convenient to define
\begin{eqnarray}
a^{(-)}_\alpha(0) &=& -\frac{v_\alpha(L_s-1)}{w_\alpha(0)}, \\
a^{(-)}_\alpha(k) &=& - \frac{a^{(-)}_\alpha(k-1)u_\alpha(k-1)}{w_\alpha(k)}, \\
z^{(-)}_\alpha & = & \frac{1}{w_\alpha(L_s-1)(1-a^{(-)}_\alpha(L_s-1))},\\
b^{(-)}_\alpha(k) &=& - \frac{u_\alpha(k)}{w_\alpha(k)}, \\
c^{(-)}_\alpha(k) &=& \frac{1}{w_\alpha(k)}.
\end{eqnarray}

Then algorithm~\ref{inv-lower} could be used to compute
$\phi\leftarrow A_-^{-1}\psi$.
\IncMargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$z$, precomputed part of $A_{Y-}$}
\KwIn{$a$, precomputed part of $A_{Y-}$}
\KwIn{$b$, precomputed part of $A_{L-}$}
\KwIn{$c$, precomputed part of $A_{L-}$}
\KwIn{$\psi$, the right hand side}
\KwIn{$L_s$, flavor dimension}
\KwOut{$\phi$, the result}
\DontPrintSemicolon
\Begin{
  $\eta\leftarrow\psi_{L_s-1}$\;
  $k\leftarrow0$\;
  \For{$k<L_s-1$}{
    $\eta \leftarrow \eta + a_k\psi_k$\;
    $k\leftarrow k + 1$\;
  }
  $\phi_{L_s-1}\leftarrow\eta\leftarrow z \eta$\;
  $k\leftarrow L_s-2$\;
  \For{$k\ge 0$}{
     $\phi_k\leftarrow\eta\leftarrow b_k \eta + c_k \psi_k$\;
     $k\leftarrow k - 1$\;
  }
  \Return{$\phi$}.
}
\caption{\label{inv-lower}Computing the inverse of $A_-$.}
\end{algorithm}
\DecMargin{20pt}

\section{Combinations of $A$ and $B$}
With the notations above one can write other $s$-pieces we need:
\begin{eqnarray}
A^{-1} & = & A_{X+}^{-1}A_{L+}^{-1}P_{+}+A_{X-}^{-1}A_{L-}^{-1}P_{-}\\
A^{-1} & = & A_{L+}^{-1}A_{Y+}^{-1}P_{+}+A_{L-}^{-1}A_{Y-}^{-1}P_{-}\\
B^{-1} & = & B_{X+}^{-1}B_{L+}^{-1}P_{+}+B_{X-}^{-1}B_{L-}^{-1}P_{-}\\
B^{-1} & = & B_{L+}^{-1}B_{Y+}^{-1}P_{+}+B_{L-}^{-1}B_{Y-}^{-1}P_{-}\\
A_{+} & = & A_{L+} A_{X+} \\
A_{+} & = & A_{Y+} A_{L+} \\
A_{-} & = & A_{L-} A_{X-} \\
A_{-} & = & A_{Y-} A_{L-} \\
B_{+} & = & B_{L+} B_{X+} \\
B_{+} & = & B_{Y+} B_{L+} \\
B_{-} & = & B_{L-} B_{X-} \\
B_{-} & = & B_{Y-} B_{L-} \\
A^\dagger &=& A_{+}^\dagger P_{+}+ A_{-}^\dagger P_{-}\\
B^\dagger &=& B_{+}^\dagger P_{+}+ B_{-}^\dagger P_{-}\\
\end{eqnarray}

\chapter{ALGORITHMS}
\section{Conjugate gradient}
The equation
\[
   M^\dagger M \xi = \chi
\]
can be solve by the conjugate gradient method if the condition number of
 $M^\dagger M$ is small enough.
\IncMargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$M$, the matrix}
\KwIn{$\chi$, the right hand side of the linear equation}
\KwIn{$\xi_0$, an initial guess}
\KwIn{$n$, the maximum number of iterations}
\KwIn{$\epsilon$, required precision}
\KwOut{$\xi$, approximate solution}
\KwOut{$r$, final residue}
\KwOut{$k$, number of iterations used}
\SetKw{Break}{break}
\DontPrintSemicolon
\Begin{
  $\xi\leftarrow \xi_0$\;
  $\rho\leftarrow \chi - M^{\dagger}M\xi$\;
  $\pi\leftarrow \rho$\;
  $r\leftarrow\langle \rho,\rho\rangle$\;
  $k\leftarrow 0$\;
  \While{$r > \epsilon$ or $k < n$}{
    $\omega\leftarrow M\pi$\;
    $\zeta\leftarrow M^{\dagger}\omega$\;
    $a\leftarrow r/\langle \omega,\omega\rangle$\;
    $\rho\leftarrow \rho - a \zeta$\;
    $ g \leftarrow \langle \rho,\rho\rangle$\;
    \If{$ g<\epsilon$}{
       $\xi\leftarrow \xi+ a \pi$\;
       $r \leftarrow g$\;
       \Break}
    $b\leftarrow g/r$\;
    $r\leftarrow g$\;
    $\xi\leftarrow \xi + a \pi$\;
    $\pi\leftarrow \rho + b \pi$\;
    $k\leftarrow k + 1$\;
  }
  \Return {$\xi$, $r$, $k$}.
}
\caption{\label{real}Conjugate Gradient Solver.}
\end{algorithm}
\DecMargin{20pt}

\section{Shifted Conjugate Gradient}
We also need the ability to solve equations $(A+s_n I)\xi_n = \chi$,
$A=M^\dagger M$
for several $s_n$ and the same RHS $\chi$. It is possible to do this with
little extra work because Krylov's spaces of $A$ and $A+s_n I$ are the
same. We assume that the solution of $A\xi=\chi$ is also needed and that
 $s_n>0$ for all $n$.
% Under these assumptions the following algorithm
could be used.
For the details of the algorithm see van~der~Eshof and Sleijpen,~2003.
Notice that SCG always starts with $\xi_0=0$.

\IncMargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$M$, the matrix}
\KwIn{$s[m]$, the vector of shifts}
\KwIn{$\chi$, the right hand side}
\KwIn{$n$, the maximal number of iterations}
\KwIn{$\epsilon$, required precision for $\sigma=0$}
\KwOut{$\xi[m]$, vector of approximate solutions}
\KwOut{$\xi$, approximate solution for $\sigma=0$}
\KwOut{$r$, final residue for $s=0$}
\KwOut{$k$, number of iterations used}
\SetKw{Break}{break}
\DontPrintSemicolon
\Begin{
  $k\leftarrow 0$\;
  $\xi\leftarrow 0$\;
  $\rho \leftarrow \pi \leftarrow \chi$\;
  $r \leftarrow \langle \rho,\rho \rangle$\;
  $a_{-1}\leftarrow b_{-1}\leftarrow 1$\;
  \lForEach{$i$}{$\xi[i]\leftarrow 0$\;}
  \lForEach{$i$}{$\pi[i]\leftarrow \rho$\;}
  \lForEach{$i$}{$w[i]\leftarrow v[i]\leftarrow 1$\;}
  \While{$k < n$}{
    $\omega\leftarrow M \pi$\;
    $z \leftarrow \langle \omega, \omega\rangle$\;
    $\zeta \leftarrow M^\dagger \omega$\;
    $a\leftarrow r / z$\;
    \lForEach{$i$}{$w[i]\leftarrow 1/(1+a*(s[i]+b_{-1}*(1-w[i])/a_{-1}))$\;}
    $\rho\leftarrow \rho - a * \zeta$\;
    $g \leftarrow \langle \rho,\rho \rangle$\;
    $b\leftarrow g / r$\;
    $r\leftarrow g$\;
    \If{$ r<\epsilon$}{
        $\xi\leftarrow \xi + a * \pi$\;
        \lForEach{$i$}{$\xi[i]\leftarrow \xi[i] + (a * w[i] * v[i]) * \pi[i]$\;}
        \Break}
    $\xi\leftarrow \xi + a * \pi$\;
    \lForEach{$i$}{$\xi[i]\leftarrow \xi[i] + (a * w[i] * v[i]) * \pi[i]$\;}
    $\pi\leftarrow \rho + b * \pi$\;
    \lForEach{$i$}{$\pi[i]\leftarrow \rho+ (b*w[i])*\pi[i]$\;}
    \lForEach{$i$}{$v[i]\leftarrow v[i]*w[i]$\;}
    $b_{-1}\leftarrow b$\;
    $a_{-1}\leftarrow a$\;
    $k\leftarrow k+1$\;
  }
  \Return {$\xi[m]$, $\xi$, $r$, $k$}.
}
\caption{\label{shifted}Shifted Conjugate Gradient Solver.}
\end{algorithm}
\DecMargin{20pt}

\chapter{INTERFACE}
The MDWF interface is fully functional to isolate users of the code from
implementation details. Several types defined in the interface provide help
with typechecking.
<<File [[../port/qop-mdwf3.h]]>>=
#ifndef QOP_MDWF_0bd50d0caeec4311a0d7c183032c43c2
# define `QOP_MDWF_0bd50d0caeec4311a0d7c183032c43c2
  <<Interface macros>>
  <<Interface types>>
  <<Interface functions>>
# if defined(QOP_MDWF_DEFAULT_PRECISION) && (QOP_MDWF_DEFAULT_PRECISION == 'F')
   <<Single precision defaults>>
# endif
# if defined(QOP_MDWF_DEFAULT_PRECISION) && (QOP_MDWF_DEFAULT_PRECISION == 'D')
    <<Double precision defaults>>
# endif
#endif
@

\section{Magic numbers}
The numbers below are provided as names for magic numbers in the code. They can
not be safely changed.

First, the dimension is always four:
<<Interface macros>>=
#define `QOP_MDWF_DIM 4
@

Next, the number of components in the Dirac fermion and the projected fermion
<<Interface macros>>=
#define `QOP_MDWF_FERMION_DIM 4
#define `QOP_MDWF_PROJECTED_FERMION_DIM 2
@

We work only with $SU(3)$
<<Interface macros>>=
#define `QOP_MDWF_COLORS 3
@

\section{Library version}
The following function returns a version of the library. The goal is to
provide enough information to uniquely identify library's version. Since
there are many features packed into the library, a human-readable string is
returned.
<<Interface functions>>=
const char *`QOP_MDWF_version(void);
@

\section{Library signature}

The following function returns a constant string which specifies the
format of the deflator state. If the format of exported state deflator
changes, a different string will be returned.
<<Interface functions>>=
const char *`QOP_MDWF_signature(struct QOP_MDWF_State *state);
@

\section{Parity of even-odd preconditioning}
The parity of even-odd preconditioning used internally. The the returned value is zero,
[[QDP_even_L()]] is used internally, otherwise the internals work on [[QDP_odd_L()]].
<<Interface functions>>=
int `QOP_MDWF_parity(struct QOP_MDWF_State *state);
@

\section{Performance monitoring}
Each interface function records its exectution time and number of floating point
operations in the [[State]] structure. These numbers are accessed via the
following function. Only data on the current node is recorded. The function
returns [[0]] if performance counters are updated.
<<Interface functions>>=
int `QOP_MDWF_performance(double *time_sec,
                         long long *flops,
                         long long *sent,
                         long long *receive,
                         struct QOP_MDWF_State *state);
@

\section{Initialization}
All library state is incapsulated into an opaque structure. We do not need
to expose any components of the structure to the user.
<<Interface types>>=
struct `QOP_MDWF_State;
@

We also need an opaque type for parameters of the domain wall action.
<<Interface types>>=
struct `QOP_MDWF_Parameters;
@

Initialization needs to know lattice configuration and its layout on the machine.
It expects to find the information in the following structure
<<Interface types>>=
struct `QOP_MDWF_Config {
  int    self;                      /* this node QMP id */
  int    master_p;                  /* if != 0, do I/O from this node */
  int    rank;                      /* lattice rank, must be 4 */
  int   *lat;                       /* [rank] */
  int    ls;                        /* lattice extend in the flavor dimension */
  int   *net;                       /* [rank] */
  int   *neighbor_up;               /* [rank], QMP ids of neighbors in up dirs */
  int   *neighbor_down;             /* [rank], QMP ids of neighbors in down dirs */
  void (*sublattice)(int lo[],      /*   [rank] */
                     int hi[],      /*   [rank] */
                     int node,      /*   any node QMP id */
                     void *env);    /*   lexical variables */
  void  *env;                       /* lexical variables for sublattice */
};
@
This structure is used by [[QOP_MDWF_init()]] only. Once the initialization is done,
the elements of the structure (and data they point to) will never be referenced again.


The library initialization routine creates the state structure and fills it
with necessary information. It returns [[0]] if successful and a non-zero value
otherwise. In any case [[state_ptr]] is set to some value suitable for other
library functions.
<<Interface functions>>=
int `QOP_MDWF_init(struct QOP_MDWF_State **state_ptr,
                  struct QOP_MDWF_Config *config);
@
Arguments of [[init()]] are
\begin{itemize}
\item[\texttt{state\_ptr}] points to the [[State]] to be set.
\item[\texttt{config}] lattice layout information.
\end{itemize}

When [[QOP_MDWF_init()]] returns, [[*state_ptr]] will point to a valid
state of the library (if any error occurs during initialization, the
error will be stored in [[*state_ptr]].

It is possible to call [[QOP_MDWF_init()]] multiple times with different
arguments. The library does not require that the lattice size and layout agree
in different calls.

\section{Cleanup}
When the state is no longer needed it should be closed by the following function
<<Interface functions>>=
void `QOP_MDWF_fini(struct QOP_MDWF_State **state_ptr);
@
It is an error to use [[*state_ptr]] after it was closed. To help in error
detection this function sets [[*state_ptr]] to [[NULL]]. All library functions
check if the state they are passed is [[NULL]] and abort if it is.

\section{Errors}
When something goes wrong in the library, a library function will return some
non-zero value and store the error code in the library state. The error codes
are accessible as human-readable strings via the following function:
<<Interface functions>>=
const char *`QOP_MDWF_error(struct QOP_MDWF_State *state);
@
Note that the first error will be latched until [[QOP_MDWF_error()]] is called.
This is a design choice made to help in pinpointing the origin of the problem
when something goes wrong intead of reporting spiritious errors if multiple
calls to the library are made before an error is checked for. If there is no
error, [[QOP_MDWF_error()]] returns [[NULL]]. The function could be called
multiple times, it does not reset the error code, instead it marks in the state
that the error was reported thus allowing latching another error.

\section{OpenMP control}
The library may be condifured to use OpenMP for threading on a node. The granularity of
threadable loops is controlled with
<<Interface functions>>=
int `QOP_MDWF_set_threads(struct QOP_MDWF_State *state,
                          int threads);
@
If the value of [[threads]] is non-positive and the library was compiled with OpenMP support, then the
current value of \textit{nthreads-var} ICV is used. If the library was compiled without OpenMP,
non-positive values of [[threads]] will be converted to [[1]].

\section{Parameter setting}
Following functions set parameters of the MDWF into the state. These functions
allocate [[QOP_MDWF_Parameters]] structure.
<<Interface functions>>=
int `QOP_MDWF_set_generic(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         const double b_5[],
                         const double c_5[],
                         double M_5,
                         double m);
int `QOP_MDWF_set_complex(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         const double b_5_re[],
                         const double b_5_im[],
                         const double c_5_re[],
                         const double c_5_im[],
                         double M_5,
                         double m);
@

As a convenience, specialized setups are provided as well.
For M\"obius fermions, $b_5(s) + c_5(s)=\kappa$:
<<Interface functions>>=
int `QOP_MDWF_set_Moebius(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         const double b_5[],
                         double kappa,
                         double M_5,
                         double m);
@

For Shamir fermions, $b_5(s)=a_5$, $c_5=0$:
<<Interface functions>>=
int `QOP_MDWF_set_Shamir(struct QOP_MDWF_Parameters **param_ptr,
                        struct QOP_MDWF_State *state,
                        double a_5,
                        double M_5,
                        double m);
@

For Bori\c ci, $b_5(s)=c_5(s)=a_5$:
<<Interface functions>>=
int `QOP_MDWF_set_Borichi(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         double a_5,
                         double M_5,
                         double m);
@

For Chiu, $b_5(s)=c_5(s)=a_5(s)$:
<<Interface functions>>=
int `QOP_MDWF_set_Chiu(struct QOP_MDWF_Parameters **param_ptr,
                      struct QOP_MDWF_State *state,
                      const double a_5[],
                      double M_5,
                      double m);
@
We also provide a corresponding destructor for [[QOP_MDWF_Parameters]]. This
function will write [[NULL]] back to the pointer to help in bug detection.
<<Interface functions>>=
void `QOP_MDWF_free_parameters(struct QOP_MDWF_Parameters **param_ptr);
@

\section{Gauge}
Any gauge field should be imported into the library format before it could
be used. To keep the interface as general as possible, we use a query function
approach for inport. There are two versions of [[QOP_MDWF_import_gauge]], one
for double precision, another for single precision.
<<Interface functions>>=
int `QOP_F3_MDWF_import_gauge(struct QOP_F3_MDWF_Gauge **gauge_ptr,
                             struct QOP_MDWF_State *state,
                             void (*reader)(double *val_re,
                                            double *val_im,
                                            int dir,
                                            const int pos[4],
                                            int a,
                                            int b,
                                            void *env),
                             void *env);
int `QOP_D3_MDWF_import_gauge(struct QOP_D3_MDWF_Gauge **gauge_ptr,
                             struct QOP_MDWF_State *state,
                             void (*reader)(double *val_re,
                                            double *val_im,
                                            int dir,
                                            const int pos[4],
                                            int a,
                                            int b,
                                            void *env),
                             void *env);
@
The [[reader()]] points to a function that provides a value of the gauge field
at a given point on the lattice, e.g., it returns the value of
[[U[dir][pos][a][b].re]] for [[re_im==0]] and 
[[U[dir][pos][a][b].im]] for [[re_im==1]]. If will be called only for [[pos]] in
a local sublattice. The [[reader()]] function is passed the [[env]] parameter
that may be used to access the guage field from the outer space.  The [[env]]
parameter is not used by [[import_gauge()]] functions for any other purpose.

If the function succeeds then the [[*gauge_ptr]] will be initialized to a value
that may be passed to other library functions. If something goes wrong,
[[*gauge_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F3_MDWF_Gauge;
struct `QOP_D3_MDWF_Gauge;
@

It is convenient to have a converter from double to single precision. It allocates space
for single precision result.
<<Interface functions>>=
int `QOP_MDWF_gauge_float_from_double(struct QOP_F3_MDWF_Gauge **result,
                                     struct QOP_D3_MDWF_Gauge *gauge_ptr);
@

We also need a couple of destructors for gauge fields. For convenience, they
will accept [[NULL]] intead of a valid gauge field.
<<Interface functions>>=
void `QOP_F3_MDWF_free_gauge(struct QOP_F3_MDWF_Gauge **gauge_ptr);
void `QOP_D3_MDWF_free_gauge(struct QOP_D3_MDWF_Gauge **gauge_ptr);
@

Here are macros defining default values for gauge field types and functions:
<<Single precision defaults>>=
#define `QOP_MDWF_import_gauge QOP_F3_MDWF_import_gauge
#define `QOP_MDWF_free_gauge QOP_F3_MDWF_free_gauge
#define `QOP_MDWF_Gauge QOP_F3_MDWF_Gauge
@
<<Double precision defaults>>=
#define `QOP_MDWF_import_gauge QOP_D3_MDWF_import_gauge
#define `QOP_MDWF_free_gauge QOP_D3_MDWF_free_gauge
#define `QOP_MDWF_Gauge QOP_D3_MDWF_Gauge
@

\section{Fermions}
Unlike the gauge field, fermions are provided with a richer set of functions.
In addition to import and destruction, they could be created empty and exported.
<<Interface functions>>=
int `QOP_F3_MDWF_import_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr,
                               struct QOP_MDWF_State *state,
                               void (*reader)(double *val_re,
                                              double *val_im,
                                              const int pos[5],
                                              int color,
                                              int dirac,
                                              void *env),
                               void *env);
int `QOP_D3_MDWF_import_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr,
                               struct QOP_MDWF_State *state,
                               void (*reader)(double *val_re,
                                              double *val_im,
                                              const int pos[5],
                                              int color,
                                              int dirac,
                                              void *env),
                               void *env);
@
The [[reader()]] points to a function that provides a value of the fermion field
at a given point on the lattice, e.g., it returns the value of
[[F[pos][color][dirac].re]] for [[re_im==0]] and 
[[F[pos][color][dirac].im]] for [[re_im==1]].
If will be called only for [[pos]] in
a local sublattice. The [[env]] parameter
is passed blindly to the [[reader()]] without any interpretation whatsoever. It
could be used to access the fermion field from the outer space or for any other
purpose.

If the function succeeds then the [[*fermion_ptr]] will be initialized to a
value that may be passed to other library functions. If something goes wrong,
[[*fermion_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F3_MDWF_Fermion;
struct `QOP_D3_MDWF_Fermion;
@

One may also need to create a fermion field without any useful initial value.
For convenience, we provide functions to do that
<<Interface functions>>=
int `QOP_F3_MDWF_allocate_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr,
                                 struct QOP_MDWF_State *state);
int `QOP_D3_MDWF_allocate_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr,
                                 struct QOP_MDWF_State *state);
@

Unlike the gauge fields, fermions need a way to be exported back to the user.
We also use a functional interface to provide indexing.
<<Interface functions>>=
int `QOP_F3_MDWF_export_fermion(void (*writer)(const int pos[5],
                                              int color,
                                              int dirac,
                                              double val_re,
                                              double val_im,
                                              void *env),
                               void *env,
                               const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_export_fermion(void (*writer)(const int pos[5],
                                              int color,
                                              int dirac,
                                              double val_re,
                                              double val_im,
                                              void *env),
                               void *env,
                               const struct QOP_D3_MDWF_Fermion *fermion);
@
We also provide convenience routines to import four-dimensional
fermions
<<Interface functions>>=
int `QOP_F3_MDWF_import_4d_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr,
                                  struct QOP_MDWF_State *state,
                                  void (*reader)(double *val_re,
                                                 double *val_im,
                                                 const int pos[4],
                                                 int color,
                                                 int dirac,
                                                 void *env),
                                  void *env);
int `QOP_D3_MDWF_import_4d_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr,
                                  struct QOP_MDWF_State *state,
                                  void (*reader)(double *val_re,
                                                 double *val_im,
                                                 const int pos[4],
                                                 int color,
                                                 int dirac,
                                                 void *env),
                                  void *env);
@
Export routines are provided as well:
<<Interface functions>>=
int `QOP_F3_MDWF_export_4d_fermion(void (*writer)(const int pos[4],
                                                 int color,
                                                 int dirac,
                                                 double val_re,
                                                 double val_im,
                                                 void *env),
                                  void *env,
                                  const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_export_4d_fermion(void (*writer)(const int pos[4],
                                                 int color,
                                                 int dirac,
                                                 double val_re,
                                                 double val_im,
                                                 void *env),
                                  void *env,
                                  const struct QOP_D3_MDWF_Fermion *fermion);
@
For residual mass calculations, one needs the
following routines:
<<Interface functions>>=
int `QOP_F3_MDWF_midpoint_pseudo(void (*writer)(const int pos[4],
                                               double value,
                                               void *env),
                                void *env,
                                const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_midpoint_pseudo(void (*writer)(const int pos[4],
                                               double value,
                                               void *env),
                                void *env,
                                const struct QOP_D3_MDWF_Fermion *fermion);
@
It is also convenient to have the conserved axial current export (it is real by
construction):
<<Interface functions>>=
int `QOP_F3_MDWF_axial_current(void (*writer)(const int pos[4],
                                             int dir,
                                             double value,
                                             void *env),
                              void *env,
                              const struct QOP_F3_MDWF_Fermion *fermion,
                              const struct QOP_F3_MDWF_Gauge *gauge);
int `QOP_D3_MDWF_axial_current(void (*writer)(const int pos[4],
                                             int dir,
                                             double value,
                                             void *env),
                              void *env,
                              const struct QOP_D3_MDWF_Fermion *fermion,
                              const struct QOP_D3_MDWF_Gauge *gauge);
@

We also need a couple of destructors for fermion fields. For convenience, they
will accept [[NULL]] intead of a valid fermion field.
<<Interface functions>>=
void `QOP_F3_MDWF_free_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr);
void `QOP_D3_MDWF_free_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr);
@

Finally, macros for prefered precision
<<Single precision defaults>>=
#define `QOP_MDWF_import_fermion QOP_F3_MDWF_import_fermion
#define `QOP_MDWF_import_4d_fermion QOP_F3_MDWF_import_4d_fermion
#define `QOP_MDWF_export_fermion QOP_F3_MDWF_export_fermion
#define `QOP_MDWF_export_4d_fermion QOP_F3_MDWF_export_4d_fermion
#define `QOP_MDWF_allocate_fermion QOP_F3_MDWF_allocate_fermion
#define `QOP_MDWF_midpoint_pseudo QOP_F3_MDWF_midpoint_pseudo
#define `QOP_MDWF_axial_current QOP_F3_MDWF_axial_current
#define `QOP_MDWF_free_fermion QOP_F3_MDWF_free_fermion
#define `QOP_MDWF_Fermion QOP_F3_MDWF_Fermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_import_fermion QOP_D3_MDWF_import_fermion
#define `QOP_MDWF_import_4d_fermion QOP_D3_MDWF_import_4d_fermion
#define `QOP_MDWF_export_fermion QOP_D3_MDWF_export_fermion
#define `QOP_MDWF_export_4d_fermion QOP_D3_MDWF_export_4d_fermion
#define `QOP_MDWF_allocate_fermion QOP_D3_MDWF_allocate_fermion
#define `QOP_MDWF_midpoint_pseudo QOP_D3_MDWF_midpoint_pseudo
#define `QOP_MDWF_axial_current QOP_D3_MDWF_axial_current
#define `QOP_MDWF_free_fermion QOP_D3_MDWF_free_fermion
#define `QOP_MDWF_Fermion QOP_D3_MDWF_Fermion
@

\section{Preconditioned fermions}
We also need preconditioned fermions. They exist in parallel to full fermions
but the exact relation is not specified.
Unlike the gauge field, fermions are provided with a richer set of functions.
In addition to import and destruction, they could be created empty and exported.
<<Interface functions>>=
int `QOP_F3_MDWF_import_half_fermion(struct QOP_F3_MDWF_HalfFermion **hfermion_ptr,
                                    struct QOP_MDWF_State *state,
                                    void (*reader)(double *val_re,
                                                   double *val_im,
                                                   const int pos[5],
                                                   int color,
                                                   int dirac,
                                                   void *env),
                                    void *env);
int `QOP_D3_MDWF_import_half_fermion(struct QOP_D3_MDWF_HalfFermion **hfermion_ptr,
                                    struct QOP_MDWF_State *state,
                                    void (*reader)(double *val_re,
                                                   double *val_im,
                                                   const int pos[5],
                                                   int color,
                                                   int dirac,
                                                   void *env),
                                    void *env);
@
The [[reader()]] points to a function that provides a value of the
preconditioned fermion field
at a given point on the lattice, e.g., it returns the value of
[[F[pos][color][dirac].re]] for [[re_im==0]] and 
[[F[pos][color][dirac].im]] for [[re_im==1]].
If will be called only for [[pos]] in
a local sublattice. The [[env]] parameter
is passed blindly to the [[reader()]] without any interpretation whatsoever. It
could be used to access the half fermion in the calling layer.

If the function succeeds then the [[*hfermion_ptr]] will be initialized to a
value that may be passed to other library functions. If something goes wrong,
[[*hfermion_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F3_MDWF_HalfFermion;
struct `QOP_D3_MDWF_HalfFermion;
@

One may also need to create a fermion field without any useful initial value.
For convenience, we provide functions to do that
<<Interface functions>>=
int `QOP_F3_MDWF_allocate_half_fermion(struct QOP_F3_MDWF_HalfFermion **hfermion_ptr,
                                      struct QOP_MDWF_State *state);
int `QOP_D3_MDWF_allocate_half_fermion(struct QOP_D3_MDWF_HalfFermion **hfermion_ptr,
                                      struct QOP_MDWF_State *state);
@

Preconditioned fermions may be exported back to the user.
We also use a functional interface to provide indexing.
<<Interface functions>>=
int `QOP_F3_MDWF_export_half_fermion(void (*writer)(const int pos[5],
                                                   int color,
                                                   int dirac,
                                                   double val_re,
                                                   double val_im,
                                                   void *env),
                                   void *env,
                                   const struct QOP_F3_MDWF_HalfFermion *hfermion);
int `QOP_D3_MDWF_export_half_fermion(void (*writer)(const int pos[5],
                                                   int color,
                                                   int dirac,
                                                   double val_re,
                                                   double val_im,
                                                   void *env),
                                   void *env,
                                   const struct QOP_D3_MDWF_HalfFermion *hfermion);
@

A fast path interface to BLAS allows one to convert between a half-fermion
and an array of float (actually complex) numbers that BLAS and friends prefer.
The [[size]] parameters must be at least as large as the value returned by [[QDP_MDWF_half_fermion_size()]] below.
Export function write exactly [[QDP_MDWF_half_fermion_size()]] numbers to [[data]];
import functions read exactly [[QDP_MDWF_half_fermion_size()]] numbers from [[data]].
<<Interface functions>>=
int `QOP_F3_MDWF_blas_from_half_fermion(float *data,
                                       int size,
                                       const struct QOP_F3_MDWF_HalfFermion *hfermion);
int `QOP_D3_MDWF_blas_from_half_fermion(double *data,
                                       int size,
                                       const struct QOP_D3_MDWF_HalfFermion *hfermion);
int `QOP_F3_MDWF_half_fermion_from_blas(struct QOP_F3_MDWF_HalfFermion *hfermion,
                                       const float *data,
                                       int size);
int `QOP_D3_MDWF_half_fermion_from_blas(struct QOP_D3_MDWF_HalfFermion *hfermion,
                                       const double *data,
                                       int size);
@
We also provide a way to determine the number of floating point numbers needed to represent a half-fermion.
<<Interface functions>>=
int `QOP_MDWF_half_fermion_size(struct QOP_MDWF_State *state_ptr);
@

We also need a couple of destructors for fermion fields. For convenience, they
will accept [[NULL]] intead of a valid fermion field.
<<Interface functions>>=
void `QOP_F3_MDWF_free_half_fermion(struct QOP_F3_MDWF_HalfFermion **hfermion_ptr);
void `QOP_D3_MDWF_free_half_fermion(struct QOP_D3_MDWF_HalfFermion **hfermion_ptr);
@

Finally, macros for prefered precision
<<Single precision defaults>>=
#define `QOP_MDWF_import_half_fermion QOP_F3_MDWF_import_half_fermion
#define `QOP_MDWF_export_half_fermion QOP_F3_MDWF_export_half_fermion
#define `QOP_MDWF_allocate_half_fermion QOP_F3_MDWF_allocate_half_fermion
#define `QOP_MDWF_blas_from_half_fermion QOP_F3_MDWF_blas_from_half_fermion
#define `QOP_MDWF_half_fermion_from_blas QOP_F3_MDWF_half_fermion_from_blas
#define `QOP_MDWF_free_half_fermion QOP_F3_MDWF_free_half_fermion
#define `QOP_MDWF_HalfFermion QOP_F3_MDWF_HalfFermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_import_half_fermion QOP_D3_MDWF_import_half_fermion
#define `QOP_MDWF_export_half_fermion QOP_D3_MDWF_export_half_fermion
#define `QOP_MDWF_allocate_half_fermion QOP_D3_MDWF_allocate_half_fermion
#define `QOP_MDWF_blas_from_half_fermion QOP_D3_MDWF_blas_from_half_fermion
#define `QOP_MDWF_half_fermion_from_blas QOP_D3_MDWF_half_fermion_from_blas
#define `QOP_MDWF_free_half_fermion QOP_D3_MDWF_free_half_fermion
#define `QOP_MDWF_HalfFermion QOP_D3_MDWF_HalfFermion
@

\section{Fermion Vectors}
For shifted conjugate gradient solver we need vectors of preconditioned
fermions. To the user only an opaque data type is presented.
<<Interface types>>=
struct QOP_F3_MDWF_VectorFermion;
struct QOP_D3_MDWF_VectorFermion;
@

 First, the allocator. It takes a number of elements in the vector and
returns an opaque vector fermion object.
<<Interface functions>>=
int `QOP_F3_MDWF_allocate_vector_fermion(struct QOP_F3_MDWF_VectorFermion **vf_ptr,
                                        struct QOP_MDWF_State *state,
                                        int n);
int `QOP_D3_MDWF_allocate_vector_fermion(struct QOP_D3_MDWF_VectorFermion **vf_ptr,
                                       struct QOP_MDWF_State *state,
                                       int n);
@
Destructors of the vector fermions accept [[NULL]] in addition to a valid vector fermion pointer.
<<Interface functions>>=
void `QOP_F3_MDWF_free_vector_fermion(struct QOP_F3_MDWF_VectorFermion **vf_ptr);
void `QOP_D3_MDWF_free_vector_fermion(struct QOP_D3_MDWF_VectorFermion **vf_ptr);
@

We also provide primitive access procedures (mnemonic convention is
``get from vector'' and ``put into vector''):
<<Interface functions>>=
int `QOP_F3_MDWF_get_vector_fermion(struct QOP_F3_MDWF_HalfFermion *hf,
                                   const struct QOP_F3_MDWF_VectorFermion *vf,
                                   int index);
int `QOP_D3_MDWF_get_vector_fermion(struct QOP_D3_MDWF_HalfFermion *hf,
                                   const struct QOP_D3_MDWF_VectorFermion *vf,
                                   int index);
int `QOP_F3_MDWF_put_vector_fermion(struct QOP_F3_MDWF_VectorFermion *vf,
                                   int index,
                                   const struct QOP_F3_MDWF_HalfFermion *hf);
int `QOP_D3_MDWF_put_vector_fermion(struct QOP_D3_MDWF_VectorFermion *vf,
                                   int index,
                                   const struct QOP_D3_MDWF_HalfFermion *hf);
@

Macros for default precision:
<<Single precision defaults>>=
#define `QOP_MDWF_allocate_vector_fermion QOP_F3_MDWF_allocate_vector_fermion
#define `QOP_MDWF_free_vector_fermion QOP_F3_MDWF_free_vector_fermion
#define `QOP_MDWF_get_vector_fermion QOP_F3_MDWF_get_vector_fermion
#define `QOP_MDWF_put_vector_fermion QOP_F3_MDWF_put_vector_fermion
#define `QOP_MDWF_VectorFermion QOP_F3_MDWF_VectorFermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_allocate_vector_fermion QOP_D3_MDWF_allocate_vector_fermion
#define `QOP_MDWF_free_vector_fermion QOP_D3_MDWF_free_vector_fermion
#define `QOP_MDWF_get_vector_fermion QOP_D3_MDWF_get_vector_fermion
#define `QOP_MDWF_put_vector_fermion QOP_D3_MDWF_put_vector_fermion
#define `QOP_MDWF_VectorFermion QOP_D3_MDWF_VectorFermion
@

\section{Dirac Operator}
We provide both normal and conjugated Dirac Operator for the full fermion as
well as the precondition operator and its conjugate both in single and double
precision.
<<Interface functions>>=
int `QOP_F3_MDWF_DDW_operator(struct QOP_F3_MDWF_Fermion *result,
                             const struct QOP_MDWF_Parameters *params,
                             const struct QOP_F3_MDWF_Gauge *gauge,
                             const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_DDW_operator(struct QOP_D3_MDWF_Fermion *result,
                             const struct QOP_MDWF_Parameters *params,
                             const struct QOP_D3_MDWF_Gauge *gauge,
                             const struct QOP_D3_MDWF_Fermion *fermion);
@
<<Interface functions>>=
int `QOP_F3_MDWF_DDW_operator_conjugated(struct QOP_F3_MDWF_Fermion *result,
                                        const struct QOP_MDWF_Parameters *params,
                                        const struct QOP_F3_MDWF_Gauge *gauge,
                                        const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_DDW_operator_conjugated(struct QOP_D3_MDWF_Fermion *result,
                                        const struct QOP_MDWF_Parameters *params,
                                        const struct QOP_D3_MDWF_Gauge *gauge,
                                        const struct QOP_D3_MDWF_Fermion *fermion);
@
<<Interface functions>>=
int `QOP_F3_MDWF_M_operator(struct QOP_F3_MDWF_HalfFermion *result,
                           const struct QOP_MDWF_Parameters *params,
                           const struct QOP_F3_MDWF_Gauge *gauge,
                           const struct QOP_F3_MDWF_HalfFermion *fermion);
int `QOP_D3_MDWF_M_operator(struct QOP_D3_MDWF_HalfFermion *result,
                           const struct QOP_MDWF_Parameters *params,
                           const struct QOP_D3_MDWF_Gauge *gauge,
                           const struct QOP_D3_MDWF_HalfFermion *fermion);
@
<<Interface functions>>=
int `QOP_F3_MDWF_M_operator_conjugated(struct QOP_F3_MDWF_HalfFermion *result,
                                      const struct QOP_MDWF_Parameters *params,
                                      const struct QOP_F3_MDWF_Gauge *gauge,
                                      const struct QOP_F3_MDWF_HalfFermion *fermion);
int `QOP_D3_MDWF_M_operator_conjugated(struct QOP_D3_MDWF_HalfFermion *result,
                                      const struct QOP_MDWF_Parameters *params,
                                      const struct QOP_D3_MDWF_Gauge *gauge,
                                      const struct QOP_D3_MDWF_HalfFermion *fermion);
@

Also the default precision macros
<<Single precision defaults>>=
#define `QOP_MDWF_DDW_operator QOP_F3_MDWF_DDW_operator
#define `QOP_MDWF_DDW_operator_conjugated QOP_F3_MDWF_DDW_operator_conjugated
#define `QOP_MDWF_M_operator QOP_F3_MDWF_M_operator
#define `QOP_MDWF_M_operator_conjugated QOP_F3_MDWF_M_operator_conjugated
@
<<Double precision defaults>>=
#define `QOP_MDWF_DDW_operator QOP_D3_MDWF_DDW_operator
#define `QOP_MDWF_DDW_operator_conjugated QOP_D3_MDWF_DDW_operator_conjugated
#define `QOP_MDWF_M_operator QOP_D3_MDWF_M_operator
#define `QOP_MDWF_M_operator_conjugated QOP_D3_MDWF_M_operator_conjugated
@
\section{Deflation}
For delfation solvers, the following interface is provided. Deflators are used
by the deflation solvers to keep low eigenvalue vector space. Low eigenmode space 
can be either accumulated while solving Dirac equations (EigCG) or loaded into 
a deflator. There are two way to load vectors: one by one or as a blas matrix.
In the latter case, a BLAS matrix must be pre-allocated as 
[[(...)_HalfFermionMat]] and filled following the site/spin/color conventions 
compatible with [[(...)_blas_from_half_fermion]]. In practice, such a matrix is 
allocated and used in Lanczos iterations, and later supplied to create a deflator 
object; in-place conversion helps to avoid copying vectors and allocating the 
associated memory twice. Vectors may be exported from the deflator one by one.
Currently, only single precision deflator is built by default.

The state of the deflator is packaged into an opaque structure:
<<Interface types>>=
struct `QOP_F3_MDWF_Deflator;
@

The deflators are created with given capacity, size and precision:
<<Interface functions>>=
int `QOP_F3_MDWF_create_deflator(struct QOP_F3_MDWF_Deflator **defl_ptr,
                                struct QOP_MDWF_State       *state,
                                int nev, int vsize, double eps, int umax);
@

Alternatively, one can use a user-filled BLAS matrix (sequence of BLAS vectors),
from which the first [[hfm_nev]] vectors are used for deflation, and the
remaining space in the allocated matrix may be filled with additional vectors
from EigCG (but not to exceed [[eigcg_umax]]). Workspace for EigCG is allocated
if and only if [[eigcg_vmax]], [[eigcg_nev]] $>0$:
<<Interface functions>>=
int `QOP_F3_MDWF_create_deflator_inplace(struct QOP_F3_MDWF_Deflator       **defl_ptr,
                                        const struct QOP_MDWF_Parameters  *params,
                                        const struct QOP_F3_MDWF_Gauge    *gauge,
                                        struct QOP_F3_MDWF_HalfFermionMat **hfm_ptr,
                                        int                               hfm_nev,
                                        int                               eigcg_vmax,
                                        int                               eigcg_nev,
                                        double                            eigcg_eps,
                                        int                               eigcg_umax);
@

The BLAS-like space handler [[hfm_ptr]] has an opaque type
<<Interface types>>=
struct `QOP_F3_MDWF_HalfFermionMat;
@
and must be preallocated by the function
<<Interface functions>>=
int `QOP_F3_MDWF_alloc_half_fermion_matrix(struct QOP_F3_MDWF_HalfFermionMat **hfm_ptr,
                                           struct QOP_MDWF_State *state,
                                           int ncol);
@
A [[HalfFermionMat]] object is essentially a wrapper for a BLAS-style matrix; 
to use it as such, the following function provides a raw pointer to the data, 
together with the number of rows and columns and the ``leading dimension'' 
of the array:
<<Interface functions>>=
int `QOP_F3_MDWF_blas_view_half_fermion_matrix(struct QOP_F3_MDWF_HalfFermionMat *hfm_ptr,
                                              int        *nrow_loc,
                                              int        *ncol,
                                              float      **blas_ptr,
                                              int        *blas_ld);
@
The element order in the matrix conforms to [[FORTRAN]] conventions, that is
\begin{eqnarray*}
\mathrm{Re } M_{ij} &=& (*\mathtt{blas\_ptr})[2*i + 2*j*\mathtt{blas\_ld}]\,,\\
\mathrm{Im } M_{ij} &=& (*\mathtt{blas\_ptr})[2*i + 2*j*\mathtt{blas\_ld} + 1]\,,\\
& & 0\le i<\mathtt{nrow\_loc},\quad 0\le j<\mathtt{ncol}\,,
\end{eqnarray*}
and [[nrow_loc]] is the local vector size (complex numbers per process). 
The $j$-th column represents the $j$-th vector.
Once a [[HalfFermionMat]] object is used to create a deflator, it cannot be 
reused since its allocated memory belongs to the new deflator. For this reason,
[[create_deflator_inplace]] actually deallocates the associated storage structures
and sets [[*hfm_ptr]] to [[NULL]]. The following function may be called 
to manually deallocate a [[HalfFermionMat]] object ([[NULL]] pointer-safe):
<<Interface functions>>=
void QOP_F3_MDWF_free_half_fermion_matrix(struct QOP_F3_MDWF_HalfFermionMat **hfm_ptr);
@


Once done, the deflators must be freed with the following functions:
<<Interface functions>>=
void `QOP_F3_MDWF_free_deflator(struct QOP_F3_MDWF_Deflator **defl_ptr);
@

\textbf{Functions to control the state of the deflator.} 
If one needs to keep the handle but purge the stored or EigCG-accumulated data, 
there is a [[eigcg_reset]] operation:
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_eigcg_reset(struct QOP_F3_MDWF_Deflator *defl_ptr);
@

To control collection of the Krylov space, use [[eigcg_stop]] and [[eigcg_resume]]. 
While the EigCG is stopped, it can still be used in the deflated solver and
queried about accumulated eigenvalues.
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_eigcg_stop(struct QOP_F3_MDWF_Deflator *defl_ptr);
int `QOP_F3_MDWF_deflator_eigcg_resume(struct QOP_F3_MDWF_Deflator *defl_ptr);
@
The following fuction may be used to inquire the state of EigCG:
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_eigcg_is_stopped(struct QOP_F3_MDWF_Deflator *defl_ptr);
@

The current dimension of low space may be requested from the deflator:
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_current_dim(struct QOP_F3_MDWF_Deflator *defl_ptr);
@

Extract a vector from the deflator. If the vector index is out of range, nothing is
written into memory and a non-zero value is returned.
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_extract_vector(struct QOP_F3_MDWF_HalfFermion *hfermion_ptr,
                                        const struct QOP_F3_MDWF_Deflator *defl_ptr,
                                        int idx);
@

Before adding vectors to the deflator, it must be marked to prevent accidental 
changes to the deflator state
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_start_load(struct QOP_F3_MDWF_Deflator *defl_ptr);
@

Manually add a vector to the deflator. Zero value is returned if the insersion was a success.
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_add_vector(const struct QOP_MDWF_Parameters *params,
                                    const struct QOP_F3_MDWF_Gauge *gauge,
                                    struct QOP_F3_MDWF_Deflator *deflator,
                                    const struct QOP_F3_MDWF_HalfFermion *hfermion);
@

After a set of vector is loaded, the deflator should be released before using it in an inverter
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_stop_load(struct QOP_F3_MDWF_Deflator *defl_ptr);
@

The deflator can return its current estimate of the eigenvalues if it has it.
There are either [[nev]] eigenmode estimates, or none. If the deflator does
not have the estimates, [[eigen]] returns [[1]], otherwise it
returns [[0]].
<<Interface functions>>=
int `QOP_F3_MDWF_deflator_eigen(int n, double *eigen_values,
                               struct QOP_F3_MDWF_Deflator *defl_ptr);
@

\section{Solvers}
We provide three solvers for the Dirac operator. All solvers can optionally
compute true CG and Dirac residuals on each iteration. Constants below can be
bitwise combined to select which residual are computed and printed. The
behavior of the solvers do not change when residuals are selected. Applications
should not assume particular values of the constants except that
[[QOP_MDWF_LOG_NONE]] is zero.
<<Interface types>>=
enum {
   `QOP_MDWF_LOG_NONE              = 0x00,
   `QOP_MDWF_LOG_CG_RESIDUAL       = 0x01,
   `QOP_MDWF_LOG_TRUE_RESIDUAL     = 0x02,
   `QOP_MDWF_FINAL_CG_RESIDUAL     = 0x04,
   `QOP_MDWF_FINAL_DIRAC_RESIDUAL  = 0x08,
   `QOP_MDWF_LOG_EIG_UPDATE1       = 0x10,
   `QOP_MDWF_LOG_EIG_POSTAMBLE     = 0x20,
   `QOP_MDWF_LOG_EVERYTHING        = 0x3f
};
@

First, the convenience routine to solve $D_{DW}\psi=\eta$. At most
[[max_iterations]] are performed, the CG stops when the iterative precontioned
residue becomes $\epsilon$ or less.
If conjugate gradient converges, zero is returned. In this case
[[out_iterations]] contains the number of iterations and [[out_epsilon]]
contains normalized iterative CG residual.

<<Interface functions>>=
int `QOP_F3_MDWF_DDW_CG(struct QOP_F3_MDWF_Fermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_F3_MDWF_Fermion *chi_0,
                       const struct QOP_F3_MDWF_Gauge *gauge,
                       const struct QOP_F3_MDWF_Fermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
int `QOP_D3_MDWF_DDW_CG(struct QOP_D3_MDWF_Fermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_D3_MDWF_Fermion *x_0,
                       const struct QOP_D3_MDWF_Gauge *gauge,
                       const struct QOP_D3_MDWF_Fermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
@
The mixed precision solver uses the trick communicated by Stefan Krieg: run the
CG in single precision while accumulating the result in double. It has only
a double precision version and takes an extra parameter [[f_iterations]] which
controls the number of float CG iterations between double updates.
<<Interface functions>>=
int `QOP_MDWF_mixed_DDW_CG(struct QOP_D3_MDWF_Fermion *result,
                           int *out_iterations,
                           double *out_epsilon,
                           const struct QOP_MDWF_Parameters *params,
                           const struct QOP_D3_MDWF_Fermion *x_0,
                           const struct QOP_D3_MDWF_Gauge *gauge,
                           const struct QOP_D3_MDWF_Fermion *rhs,
                           int f_iterations,
                           double f_epsilon,
                           int max_iteration,
                           double epsilon,
                           unsigned int options);
@                      

A solver for $D^\dagger D\psi = \eta$ is also provided:
<<Interface functions>>=
int `QOP_F3_MDWF_DxD_CG(struct QOP_F3_MDWF_Fermion *psi,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_F3_MDWF_Fermion *psi_0,
                       const struct QOP_F3_MDWF_Gauge *gauge,
                       const struct QOP_F3_MDWF_Fermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
int `QOP_D3_MDWF_DxD_CG(struct QOP_D3_MDWF_Fermion *psi,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_D3_MDWF_Fermion *psi_0,
                       const struct QOP_D3_MDWF_Gauge *gauge,
                       const struct QOP_D3_MDWF_Fermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
@

We also expose the preconditioned hermitian solver for
$M^\dagger M\psi_e=\phi_e$. In this case the CG starts from $\psi_e$.
If conjugate gradient converges, zero is returned. In this case
[[out_iterations]] contains the number of iterations and [[out_epsilon]]
contains normalized iterative CG residual.
<<Interface functions>>=
int `QOP_F3_MDWF_MxM_CG(struct QOP_F3_MDWF_HalfFermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_F3_MDWF_Gauge *gauge,
                       const struct QOP_F3_MDWF_HalfFermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
int `QOP_D3_MDWF_MxM_CG(struct QOP_D3_MDWF_HalfFermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_D3_MDWF_Gauge *gauge,
                       const struct QOP_D3_MDWF_HalfFermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
@

A collection of preconditioned equations with different positive shifts can be
solved with very little extra cost using Algorithm~\ref{shifted}.
<<Interface functions>>=
int `QOP_F3_MDWF_MxM_SCG(struct QOP_F3_MDWF_VectorFermion *vector_result,
                        struct QOP_F3_MDWF_HalfFermion *scalar_result,
                        int *out_iterations,
                        double *out_epsilon,
                        const struct QOP_MDWF_Parameters *params,
                        const double shift[],
                        const struct QOP_F3_MDWF_Gauge *gauge,
                        const struct QOP_F3_MDWF_HalfFermion *rhs,
                        int max_iterations,
                        double min_epsilon,
                        unsigned int options);
int `QOP_D3_MDWF_MxM_SCG(struct QOP_D3_MDWF_VectorFermion *vector_result,
                        struct QOP_D3_MDWF_HalfFermion *scalar_result,
                        int *out_iterations,
                        double *out_epsilon,
                        const struct QOP_MDWF_Parameters *params,
                        const double shift[],
                        const struct QOP_D3_MDWF_Gauge *gauge,
                        const struct QOP_D3_MDWF_HalfFermion *rhs,
                        int max_iterations,
                        double min_epsilon,
                        unsigned int options);
@

A mixed precision deflated solver is provided. The interface is basically
the same as the plain mixed solver above with addition of an extra parameter
for the deflator state.

<<Interface functions>>=
int `QOP_MDWF_deflated_mixed_D_CG(struct QOP_D3_MDWF_Fermion *result,
                                 int *out_iterations,
                                 double *out_epsilon,
                                 const struct QOP_MDWF_Parameters *params,
                                 const struct QOP_D3_MDWF_Fermion *chi_0,
                                 const struct QOP_D3_MDWF_Gauge *gauge,
                                 const struct QOP_D3_MDWF_Fermion *rhs,
                                 struct QOP_F3_MDWF_Deflator *deflator,
                                 int f_iterations,
                                 double f_epsilon,
                                 int max_iteration,
                                 double epsilon,
                                 unsigned int options);
@

Again, macros
<<Single precision defaults>>=
#define `QOP_MDWF_DDW_CG QOP_F3_MDWF_DDW_CG
#define `QDP_MDWF_DxD_CG QOP_F3_MDWF_DxD_CG
#define `QOP_MDWF_MxM_CG QOP_F3_MDWF_MxM_CG
#define `QOP_MDWF_MxM_SCG QOP_F3_MDWF_MxM_SCG
@
<<Double precision defaults>>=
#define `QOP_MDWF_DDW_CG QOP_D3_MDWF_DDW_CG
#define `QDP_MDWF_DxD_CG QOP_D3_MDWF_DxD_CG
#define `QOP_MDWF_MxM_CG QOP_D3_MDWF_MxM_CG
#define `QOP_MDWF_MxM_SCG QOP_D3_MDWF_MxM_SCG
@

\section{Preconditioned operator functions}
%%%%%%%% XXXX
Apply an $n\geq1$ degree polynomial of $M^\dagger M$ to vector $\psi$. The polynomial is defined
using the general three-term recurrence relation

\begin{eqnarray*}
P_0(M^\dagger M)\psi & = & c_0 \psi \\
P_1(M^\dagger M)\psi & = & a_0 \psi + b_0 M^\dagger M \psi \\
P_n(M^\dagger M)\psi & = & (a_{n-1} + b_{n-1} M^\dagger M) P_{n-1}(M^\dagger M)\psi 
        + c_{n-1} P_{n-2}(M^\dagger M)\psi,\quad n > 1
\end{eqnarray*}

The value of $P_n(M^\dagger M)\psi$ is returned in [[result]], and if
[[result_prev]] is not [[NULL]], it shall contain the value of
$P_{n-1}(M^\dagger M)\psi$ on return.  Functions below compute operator
polynomials for positive [[n]]. Arrays [[a]], [[b]], and [[c]] contain
recursion coefficients and must be at least of length [[n]].

<<Interface functions>>=
int `QOP_F3_MDWF_MxM_poly(struct QOP_F3_MDWF_HalfFermion *result,
                         struct QOP_F3_MDWF_HalfFermion *result_prev,
                         const struct QOP_MDWF_Parameters *params,
                         const struct QOP_F3_MDWF_Gauge *gauge,
                         const struct QOP_F3_MDWF_HalfFermion *psi,
                         int n,
                         const double a[/* n */],
                         const double b[/* n */],
                         const double c[/* n */]);
int `QOP_D3_MDWF_MxM_poly(struct QOP_D3_MDWF_HalfFermion *result,
                         struct QOP_D3_MDWF_HalfFermion *result_prev,
                         const struct QOP_MDWF_Parameters *params,
                         const struct QOP_D3_MDWF_Gauge *gauge,
                         const struct QOP_D3_MDWF_HalfFermion *psi,
                         int n,
                         const double a[/* n */],
                         const double b[/* n */],
                         const double c[/* n */]);
@
The macros for default precision:
<<Single precision defaults>>=
#define `QOP_MDWF_MxM_poly QOP_F3_MDWF_MxM_poly
@
<<Double precision defaults>>=
#define `QOP_MDWF_MxM_poly QOP_D3_MDWF_MxM_poly
@

Since polynomials may have values that can cause overflow of 
floating point operations, it may be necessary to rescale these 
polynomials to some finite value.
The following function rescales the coefficients [[a]], [[b]], [[c]]
so that all the polynomials are equal to 1 at some point $x_0$, 
unless they have absolute values smaller than [[tol]]:
<<Interface functions>>=
int `QOP_MDWF_poly_normalize(int n,
                            double a[/* n */],
                            double b[/* n */],
                            double c[/* n */],
                            double x0,
                            double tol);
@

\section{Helper routines}
To avoid excessive export and import calls, we provide the following linear
algebra on full and preconditioned fermions.
\[
r\leftarrow a + \alpha b
\]
<<Interface functions>>=
int `QOP_F3_MDWF_madd_fermion(struct QOP_F3_MDWF_Fermion *r,
                             const struct QOP_F3_MDWF_Fermion *a,
                             double alpha,
                             const struct QOP_F3_MDWF_Fermion *b);
int `QOP_D3_MDWF_madd_fermion(struct QOP_D3_MDWF_Fermion *r,
                             const struct QOP_D3_MDWF_Fermion *a,
                             double alpha,
                             const struct QOP_D3_MDWF_Fermion *b);
int `QOP_F3_MDWF_madd_half_fermion(struct QOP_F3_MDWF_HalfFermion *r,
                                  const struct QOP_F3_MDWF_HalfFermion *a,
                                  double alpha,
                                  const struct QOP_F3_MDWF_HalfFermion *b);
int `QOP_D3_MDWF_madd_half_fermion(struct QOP_D3_MDWF_HalfFermion *r,
                                  const struct QOP_D3_MDWF_HalfFermion *a,
                                  double alpha,
                                  const struct QOP_D3_MDWF_HalfFermion *b);
@
\[
  \alpha \leftarrow \langle a,b\rangle
\]
<<Interface functions>>=
int `QOP_F3_MDWF_dot_fermion(double *r_re,
                            double *r_im,
                            const struct QOP_F3_MDWF_Fermion *a,
                            const struct QOP_F3_MDWF_Fermion *b);
int `QOP_D3_MDWF_dot_fermion(double *r_re,
                            double *r_im,
                            const struct QOP_D3_MDWF_Fermion *a,
                            const struct QOP_D3_MDWF_Fermion *b);
int `QOP_F3_MDWF_dot_half_fermion(double *r_re,
                                 double *r_im,
                                 const struct QOP_F3_MDWF_HalfFermion *a,
                                 const struct QOP_F3_MDWF_HalfFermion *b);
int `QOP_D3_MDWF_dot_half_fermion(double *r_re,
                                 double *r_im,
                                 const struct QOP_D3_MDWF_HalfFermion *a,
                                 const struct QOP_D3_MDWF_HalfFermion *b);
@

\[
  \alpha \leftarrow \langle a,a\rangle
\]
<<Interface functions>>=
int `QOP_F3_MDWF_norm2_fermion(double *r,
                              const struct QOP_F3_MDWF_Fermion *a);
int `QOP_D3_MDWF_norm2_fermion(double *r_re,
                              const struct QOP_D3_MDWF_Fermion *a);
int `QOP_F3_MDWF_norm2_half_fermion(double *r_re,
                                   const struct QOP_F3_MDWF_HalfFermion *a);
int `QOP_D3_MDWF_norm2_half_fermion(double *r_re,
                                   const struct QOP_D3_MDWF_HalfFermion *a);
@

Also, the macros
<<Single precision defaults>>=
#define `QOP_MDWF_madd_fermion QOP_F3_MDWF_madd_fermion
#define `QOP_MDWF_madd_half_fermion QOP_F3_MDWF_madd_half_fermion
#define `QOP_MDWF_dot_fermion QOP_F3_MDWF_dot_fermion
#define `QOP_MDWF_dot_half_fermion QOP_F3_MDWF_dot_half_fermion
#define `QOP_MDWF_norm2_fermion QOP_F3_MDWF_norm2_fermion
#define `QOP_MDWF_norm2_half_fermion QOP_F3_MDWF_norm2_half_fermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_madd_fermion QOP_D3_MDWF_madd_fermion
#define `QOP_MDWF_madd_half_fermion QOP_D3_MDWF_madd_half_fermion
#define `QOP_MDWF_dot_fermion QOP_D3_MDWF_dot_fermion
#define `QOP_MDWF_dot_half_fermion QOP_D3_MDWF_dot_half_fermion
#define `QOP_MDWF_norm2_fermion QOP_D3_MDWF_norm2_fermion
#define `QOP_MDWF_norm2_half_fermion QOP_D3_MDWF_norm2_half_fermion
@

\section{Debugging functions}
Debugging functions give direct access to internal plumbing of the library. 
Every operator\footnote{
  That is, if the developers ever suspected that any of these functions was 
  incorrectly implemented. Additional hook-ups are rather straightforward to 
  implement when necessary.
} that is used by preconditioned solvers can be accessed by the following 
function:
<<Interface functions>>=
int `QOP_F3_MDWF_debugmesilly(struct QOP_F3_MDWF_Fermion *y,
                              const struct QOP_MDWF_Parameters *params,
                              const struct QOP_F3_MDWF_Gauge *gauge,
                              const char *op_name, 
                              const struct QOP_F3_MDWF_Fermion *x);
int `QOP_D3_MDWF_debugmesilly(struct QOP_D3_MDWF_Fermion *y,
                              const struct QOP_MDWF_Parameters *params,
                              const struct QOP_D3_MDWF_Gauge *gauge,
                              const char *op_name, 
                              const struct QOP_D3_MDWF_Fermion *x);
@

This function takes a Dirac fermion [[x]], applies the operator [[op_name]] 
to it, and returns a Dirac fermion in [[y]]. 
If the operator can act only on the even part, the odd part of the argument [[x]]
will be ignored and that of the result [[y]] will be zero upon return.
If versions of the operator exist for both even and odd arguments, the result 
[[y]] will contain appropriate values for both.
Note that this function is extremely experimental and appropriate values for 
[[op_name]] may change without notice; the only way to know which operators 
are supported is to examine the code.

\appendix
\chapter{CODE CHUNKS}
\nowebchunks
\pagebreak
\chapter{SYMBOLS}
\nowebindex

\end{document}
